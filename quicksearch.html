<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_auditstream.js.html":{"id":"lib_auditstream.js.html","title":"Source: lib/auditstream.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/auditstream.js 'use strict'; var assert = require('assert'); var crypto = require('crypto'); var constants = require('./constants'); var MerkleTree = require('mtree'); var utils = require('./utils'); var stream = require('readable-stream'); var inherits = require('util').inherits; /** * Represents a streaming audit challenge generator * @constructor * @param {Number} audits - Total number of challenges to generate * @emits AuditStream#finish */ function AuditStream(audits) { if (!(this instanceof AuditStream)) { return new AuditStream(audits); } assert(typeof audits === 'number', 'Invalid number of audits supplied'); assert(!Number.isNaN(audits), 'Invalid number of audits supplied'); assert(Number.isFinite(audits), 'Invalid number of audits supplied'); this._audits = audits; this._finished = false; this._challenges = []; this._inputs = this._prepareChallenges(); stream.Writable.call(this); this.on('finish', this._generateTree.bind(this)); } /** * Triggered when the stream has ended * @event AuditStream#finish */ inherits(AuditStream, stream.Writable); /** * Returns the bottom leaves of the merkle tree for sending to farmer * @returns {Array} leaves - Bottom merkle leaves of audit tree */ AuditStream.prototype.getPublicRecord = function() { assert(this._finished, 'Challenge generation is not finished'); return this._tree.level(this._tree.levels() - 1); }; /** * Returns the challenges, the tree depth, and merkle root * @returns {Object} challenge - Private audit record with challenges */ AuditStream.prototype.getPrivateRecord = function() { assert(this._finished, 'Challenge generation is not finished'); return { root: this._tree.root(), depth: this._tree.levels(), challenges: this._challenges }; }; /** * Implements the underlying write method * @private */ AuditStream.prototype._write = function(bytes, encoding, next) { var self = this; this._inputs.forEach(function(input, i) { if (i &lt; self._audits) { input.update(bytes.toString('hex')); } }); next(); }; /** * Prepares the challenge hasher instances * @private */ AuditStream.prototype._prepareChallenges = function() { var iterations = 0; var inputs = []; while (iterations &lt; this._audits) { var challenge = this._generateChallenge(); var input = this._createResponseInput(challenge); this._challenges.push(challenge); inputs.push(input); iterations++; } while (iterations &lt; utils.getNextPowerOfTwo(this._audits)) { inputs.push(utils.rmd160sha256('')); iterations++; } return inputs; }; /** * Generate the audit merkle tree from a series of challenges * @private */ AuditStream.prototype._generateTree = function() { var self = this; this._finished = true; this._tree = new MerkleTree(this._inputs.map(function(input, i) { if (i &gt;= self._audits) { return input; } else { return utils.rmd160sha256(utils.rmd160(input.digest('hex'))); } }), utils.rmd160sha256); }; /** * Generate a random challenge buffer * @private * @returns {String} Hex encoded random bytes */ AuditStream.prototype._generateChallenge = function() { return crypto.randomBytes(constants.AUDIT_BYTES).toString('hex'); }; /** * Create a challenge response input to merkle tree * @private */ AuditStream.prototype._createResponseInput = function(challenge) { return crypto.createHash('sha256').update(challenge); }; /** * Returns a new instance from the predefined challenges and tree * @param {Array} challenges - The precomputed challenges * @param {Array} tree - The bottom leaves of the existing merkle tree * @returns {AuditStream} */ AuditStream.fromRecords = function(challenges, tree) { assert(Array.isArray(challenges), 'Invalid challenges supplied'); assert(Array.isArray(tree), 'Invalid tree supplied'); assert( tree.length === utils.getNextPowerOfTwo(challenges.length), 'Challenges and tree do not match' ); var auditor = new AuditStream(challenges.length); auditor._challenges = challenges; auditor._tree = new MerkleTree(tree, utils.rmd160sha256); auditor._finished = true; return auditor; }; module.exports = AuditStream; × Search results Close "},"lib_bridgeclient.js.html":{"id":"lib_bridgeclient.js.html","title":"Source: lib/bridgeclient.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/bridgeclient.js 'use strict'; var fs = require('fs'); var querystring = require('querystring'); var request = require('request'); var utils = require('./utils'); var FileDemuxer = require('./filedemuxer'); var FileMuxer = require('./filemuxer'); var AuditStream = require('./auditstream'); var DataChannelClient = require('./datachannel/client'); var Contact = require('./network/contact'); var crypto = require('crypto'); var tmpdir = require('os').tmpdir(); var path = require('path'); var mime = require('mime'); var uuid = require('node-uuid'); var merge = require('merge'); /** * Represents a client interface to a given bridge server * @constructor * @see https://github.com/storj/bridge * @param {String} uri - API base URI ('https://api.storj.io') * @param {Object} options * @param {KeyPair} options.keypair - KeyPair instance for request signing * @param {Object} options.basicauth * @param {String} options.basicauth.email - Email address for HTTP basic auth * @param {String} options.basicauth.password - Password for HTTP basic auth */ function BridgeClient(uri, options) { if (!(this instanceof BridgeClient)) { return new BridgeClient(uri, options); } this._options = merge({ baseURI: uri || process.env.STORJ_BRIDGE || 'https://api.storj.io' }, options); } /** * Get the remote Storj Bridge API documentation and version as JSON * @param {Function} callback */ BridgeClient.prototype.getInfo = function(callback) { return this._request('GET', '/', {}, callback); }; /** * Fetches the list of known contacts filtered according to the options * @param {Object} options * @param {Number} options.page - The page number of the contact list to fetch * @param {Boolean} options.connected - Filter results by connection status * @param {Function} callback */ BridgeClient.prototype.getContactList = function(options, callback) { return this._request('GET', '/contacts', options, callback); }; /** * Get the contact information for the given nodeID * @param {String} nodeId - The nodeID of the contact * @param {Function} callback */ BridgeClient.prototype.getContactByNodeId = function(nodeId, callback) { return this._request('GET', '/contacts/' + nodeId, {}, callback); }; /** * Registers a user account * @param {Object} options * @param {String} options.email - Email address for verification email * @param {String} options.password - Password to register (auto hashed) * @param {String} options.redirect - URL to redirect to after verification * @param {String} options.pubkey - Optional ECDSA public key to register * @param {Function} callback */ BridgeClient.prototype.createUser = function(options, callback) { return this._request('POST', '/users', { email: options.email, password: utils.sha256(options.password), redirect: options.redirect, pubkey: options.pubkey }, callback); }; /** * Returns list of associated public keys * @param {Function} callback */ BridgeClient.prototype.getPublicKeys = function(callback) { return this._request('GET', '/keys', {}, callback); }; /** * Registers a public key for the caller * @param {String} pubkey - Hex encoded ECDSA (secp256k1) public key * @param {Function} callback */ BridgeClient.prototype.addPublicKey = function(pubkey, callback) { return this._request('POST', '/keys', { key: pubkey }, callback); }; /** * Disassociates the public key from the caller * @param {String} pubkey - Hex encoded ECDSA (secp256k1) public key * @param {Function} callback */ BridgeClient.prototype.destroyPublicKey = function(pubkey, callback) { return this._request('DELETE', '/keys/' + pubkey, {}, callback); }; /** * Lists the caller's file buckets * @param {Function} callback */ BridgeClient.prototype.getBuckets = function(callback) { return this._request('GET', '/buckets', {}, callback); }; /** * Returns the bucket information by ID * @param {String} id - Unique bucket ID * @param {Function} callback */ BridgeClient.prototype.getBucketById = function(id, callback) { return this._request('GET', '/buckets/' + id, {}, callback); }; /** * Creates a new file bucket * @param {Object} data - Bucket parameters for creation * @param {Function} callback */ BridgeClient.prototype.createBucket = function(data, callback) { return this._request('POST', '/buckets', data, callback); }; /** * Removes the bucket * @param {String} id - Unique bucket ID * @param {Function} callback */ BridgeClient.prototype.destroyBucketById = function(id, callback) { return this._request('DELETE', '/buckets/' + id, {}, callback); }; /** * Updates the bucket * @param {String} id - Unique bucket ID * @param {Object} updates - Bucket update parameters * @param {Function} callback */ BridgeClient.prototype.updateBucketById = function(id, updates, callback) { return this._request('PATCH', '/buckets/' + id, updates, callback); }; /** * Lists the files stored in a bucket * @param {String} id - Unique bucket ID * @param {Function} callback */ BridgeClient.prototype.listFilesInBucket = function(id, callback) { return this._request('GET', '/buckets/' + id + '/files', {}, callback); }; /** * Create bucket token * @param {String} id - Unique bucket ID * @param {String} operation - PUSH or PULL (file operation) * @param {Function} callback */ BridgeClient.prototype.createToken = function(id, operation, callback) { return this._request('POST', '/buckets/' + id + '/tokens', { operation: operation }, callback); }; /** * Removes a file from a bucket * @param {String} id - Unique bucket ID * @param {String} file - ID of the file to remove from bucket * @param {Function} callback */ BridgeClient.prototype.removeFileFromBucket = function(id, file, callback) { return this._request( 'DELETE', '/buckets/' + id + '/files/' + file, {}, callback ); }; /** * Creates a file staging frame * @param {Function} callback */ BridgeClient.prototype.createFileStagingFrame = function(callback) { return this._request('POST', '/frames', {}, callback); }; /** * Creates a file staging frame * @param {Function} callback */ BridgeClient.prototype.getFileStagingFrames = function(callback) { return this._request('GET', '/frames', {}, callback); }; /** * Creates a file staging frame * @param {String} id - Unique frame ID * @param {Function} callback */ BridgeClient.prototype.getFileStagingFrameById = function(id, callback) { return this._request('GET', '/frames/' + id, {}, callback); }; /** * Creates a file staging frame * @param {String} id - Unique frame ID * @param {Function} callback */ BridgeClient.prototype.destroyFileStagingFrameById = function(id, callback) { return this._request('DELETE', '/frames/' + id, {}, callback); }; /** * Creates a file staging frame * @param {String} id - Unique frame ID * @param {Object} shard - The shard metadata * @param {Function} callback */ BridgeClient.prototype.addShardToFileStagingFrame = function(id, shard, cb) { return this._request('PUT', '/frames/' + id, shard, cb); }; /** * Stores a file in the bucket * @param {String} id - Unique bucket ID * @param {String} token - Token from {@link BridgeClient#createToken} * @param {String} file - Path to file to store * @param {Number} shards - Number of shards to create * @param {Function} callback */ BridgeClient.prototype.storeFileInBucket = function(id, token, file, callback) { var self = this; var numShards = Math.ceil( fs.statSync(file).size / FileDemuxer.DEFAULTS.shardSize ); var completed = 0; var cleanMe = []; var failedToUploadShard = false; function cleanup() { cleanMe.forEach(function(tmpFilePath) { fs.unlinkSync(tmpFilePath); }); } self.createFileStagingFrame(function(err, frame) { if (err) { return callback(err); } var demuxer = new FileDemuxer(file); demuxer.on('shard', function(shardStream, index) { var tmpName = path.join(tmpdir, crypto.randomBytes(6).toString('hex')); var tmpFile = fs.createWriteStream(tmpName); var hasher = crypto.createHash('sha256'); var size = 0; cleanMe.push(tmpName); shardStream.on('data', function(data) { size += data.length; hasher.update(data); tmpFile.write(data); }); shardStream.on('end', function() { tmpFile.end(); }); tmpFile.on('finish', function() { var hash = utils.rmd160(hasher.digest('hex')); var auditGenerator = new AuditStream(3); var shardFile = fs.createReadStream(tmpName); shardFile.pipe(auditGenerator).on('finish', function() { var challenges = auditGenerator.getPrivateRecord().challenges; var tree = auditGenerator.getPublicRecord(); self.addShardToFileStagingFrame(frame.id, { hash: hash, size: size, index: index, challenges: challenges, tree: tree }, function(err, pointer) { if (err) { failedToUploadShard = true; return callback(err); } var shardFile = fs.createReadStream(tmpName); var client = new DataChannelClient(Contact(pointer.farmer)); client.on('open', function() { var datachannel = client.createWriteStream( pointer.token, pointer.hash ); shardFile.pipe(datachannel).on('finish', function() { completed++; if (completed === numShards &amp;&amp; !failedToUploadShard) { cleanup(); self._request('POST', '/buckets/' + id + '/files', { frame: frame.id, mimetype: mime.lookup(file), filename: path.basename(file).split('.crypt')[0] }, callback); } }); }); }); }); }); }); }); }; /** * Retrieves a file pointer from the bucket * @param {String} bucket - Unique bucket ID * @param {String} token - Token from {@link BridgeClient#createToken} * @param {String} fileID - The unique file pointer ID * @param {Function} callback */ BridgeClient.prototype.getFilePointer = function(bucket, token, fileID, cb) { var self = this; request({ method: 'GET', baseUrl: self._options.baseURI, uri: '/buckets/' + bucket + '/files/' + fileID, headers: { 'x-token': token }, json: true }, function(err, res, body) { if (err) { return cb(err); } if (res.statusCode !== 200 &amp;&amp; res.statusCode !== 304) { return cb(new Error(body.error || body)); } cb(null, body); }); }; /** * Open a series of data channels based on the returned value of * {@link BridgeClient#getFilePointer} to resolve all the shards and * reassemble them together as a binary stream * @param {Array} pointers - Result of {@link BridgeClient#getFilePointer} * @param {Function} callback */ BridgeClient.prototype.resolveFileFromPointers = function(pointers, callback) { var opened = 0; var size = pointers.reduce(function(a, b) { return { size: a.size + b.size }; }).size; var muxer = new FileMuxer({ shards: pointers.length, length: size }); pointers.forEach(function(pointer) { var dcx = new DataChannelClient(new Contact(pointer.farmer)); dcx.on('open', function() { muxer.input(dcx.createReadStream(pointer.token, pointer.hash)); opened++; if (opened === pointers.length) { callback(null, muxer); } }); }); }; /** * Sends a request to the storj bridge * @private * @param {String} method - HTTP verb * @param {String} path - Endpoint path * @param {Object} params - Request parameters * @param {Function} callback - Return the raw response stream? */ BridgeClient.prototype._request = function(method, path, params, callback) { var opts = { baseUrl: this._options.baseURI, uri: path, method: method }; params.__nonce = uuid.v4(); if (['GET', 'DELETE'].indexOf(method) !== -1) { opts.qs = params; opts.json = true; } else { opts.json = params; } this._authenticate(opts); request(opts, function(err, res, body) { if (err) { return callback(err); } if (res.statusCode &gt;= 400) { return callback(new Error(body.error || body)); } callback(null, body); }); }; /** * Adds authentication headers to request object * @private * @param {Object} opts - Options parameter passed to request * @return {Object} */ BridgeClient.prototype._authenticate = function(opts) { if (this._options.keypair) { var payload = ['GET', 'DELETE'].indexOf(opts.method) !== -1 ? querystring.stringify(opts.qs) : JSON.stringify(opts.json); var contract = [opts.method, opts.uri, payload].join('\\n'); opts.headers = opts.headers || {}; opts.headers['x-pubkey'] = this._options.keypair.getPublicKey(); opts.headers['x-signature'] = this._options.keypair.sign(contract, { compact: false }); } else if (this._options.basicauth) { opts.auth = { user: this._options.basicauth.email, pass: utils.sha256(this._options.basicauth.password) }; } return opts; }; module.exports = BridgeClient; × Search results Close "},"lib_network_contact.js.html":{"id":"lib_network_contact.js.html","title":"Source: lib/network/contact.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/contact.js 'use strict'; var kad = require('kad'); var inherits = require('util').inherits; var protocol = require('../version').protocol; /** * Represents a Storj contact (or peer) * @constructor * @param {Object} options */ function Contact(options) { if (!(this instanceof Contact)) { return new Contact(options); } this.protocol = options.protocol || protocol; kad.contacts.AddressPortContact.call(this, options); } inherits(Contact, kad.contacts.AddressPortContact); module.exports = Contact; × Search results Close "},"lib_contract_index.js.html":{"id":"lib_contract_index.js.html","title":"Source: lib/contract/index.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/contract/index.js 'use strict'; var assert = require('assert'); var crypto = require('crypto'); var merge = require('merge'); var JSONSchema = require('jsen'); var stringify = require('json-stable-stringify'); var bitcore = require('bitcore-lib'); var constants = require('../constants'); var Message = require('bitcore-message'); var ms = require('ms'); /** * Represents a storage contract between a renter and a farmer * @constructor * @version 0 * @param {Object} contract * @param {String} contract.type - Unique identifier for the contract * @param {String} contract.renter_id - Node ID of the renter * @param {String} contract.renter_signature - Renter's cryptographic signature * @param {String} contract.farmer_id - Node ID of the farmer * @param {String} contract.farmer_signature - Farmer's cryptographic signature * @param {Number} contract.data_size - Number of bytes to store * @param {String} contract.data_hash - RIPEMD-160 SHA-256 hash of the data * @param {Number} contract.store_begin - UNIX timestamp to start contract * @param {Number} contract.store_end - UNIX timestamp to end the contract * @param {Number} contract.audit_count - Number of audits renter will perform * @param {Number} contract.payment_storage_price - Total price for storage * @param {Number} contract.payment_download_price - Price per download * @param {String} contract.payment_destination - Bitcoin address to send funds * @param {Object} criteria * @param {Number} criteria.size - Criteria degree OPCODE * @param {Number} criteria.duration - Criteria degree OPCODE * @param {Number} criteria.availability - Criteria degree OPCODE * @param {Number} criteria.speed - Criteria degree OPCODE */ function Contract(contract, criteria) { if (!(this instanceof Contract)) { return new Contract(contract, criteria); } this._properties = merge(Object.create(Contract.DEFAULTS), contract); this._validator = Contract.createValidator(); this._criteria = this._inferCriteria(criteria); this._clean(); assert.ok(this._validate(), 'Invalid contract specification was supplied'); } /** * Defines the JSON Schema of a {@link Contract} * @static */ Contract.Schema = require('./schema.json'); /** * Defines some default properties of a {@link Contract} * @static */ Contract.DEFAULTS = { version: 0, renter_id: null, renter_signature: null, farmer_id: null, farmer_signature: null, data_size: 1234, data_hash: null, store_begin: 2000000000, store_end: 3000000000, audit_count: 10, payment_storage_price: 0, payment_download_price: 0, payment_destination: null }; /** * Defines some default criteria of a {@link Contract} * @static */ Contract.CRITERIA = { size: constants.OPCODE_DEG_MED, duration: constants.OPCODE_DEG_MED, availability: constants.OPCODE_DEG_MED, speed: constants.OPCODE_DEG_MED }; /** * Defines the criteria matrix for a {@link Contract} * @static */ Contract.MATRIX = { size: function(size) { if (size &gt; 0 &amp;&amp; size &lt;= (8 * 1024 * 1024)) { return constants.OPCODE_DEG_LOW; } if (size &gt; (8 * 1024 * 1024) &amp;&amp; size &lt;= (16 * 1024 * 1024)) { return constants.OPCODE_DEG_MED; } if (size &gt; (16 * 1024 * 1024) &amp;&amp; size &lt;= (32 * 1024 * 1024)) { return constants.OPCODE_DEG_HIGH; } return null; }, duration: function(duration) { if (duration &gt; 0 &amp;&amp; duration &lt;= ms('30d')) { return constants.OPCODE_DEG_LOW; } if (duration &gt; ms('30d') &amp;&amp; duration &lt;= ms('90d')) { return constants.OPCODE_DEG_MED; } if (duration &gt; ms('90d') &amp;&amp; duration &lt;= ms('320d')) { return constants.OPCODE_DEG_HIGH; } return null; }, availability: function(availability) { if (availability &gt;= 0.5 &amp;&amp; availability &lt;= 0.7) { return constants.OPCODE_DEG_LOW; } if (availability &gt; 0.7 &amp;&amp; availability &lt;= 0.9) { return constants.OPCODE_DEG_MED; } if (availability &gt; 0.9 &amp;&amp; availability &lt;= 1) { return constants.OPCODE_DEG_HIGH; } return null; }, speed: function(speed) { if (speed &gt; 0 &amp;&amp; speed &lt;= 6) { return constants.OPCODE_DEG_LOW; } if (speed &gt; 6 &amp;&amp; speed &lt;= 12) { return constants.OPCODE_DEG_MED; } if (speed &gt; 12 &amp;&amp; speed &lt;= 32) { return constants.OPCODE_DEG_HIGH; } return null; } }; /** * Removes all properties not in the schema from contract * @private * @param {Object} criteria - Criteria degree opcodes * @returns {Object} */ Contract.prototype._inferCriteria = function(criteria) { var opcodes = Object.create(Contract.CRITERIA); opcodes.size = Contract.MATRIX.size(this.get('data_size')); opcodes.duration = Contract.MATRIX.duration( this.get('store_end') - this.get('store_begin') ); // NB: Do not try to infer availability or speed, should be explicit return merge(opcodes, criteria); }; /** * Removes all properties not in the schema from contract * @private * @returns {Contract} self */ Contract.prototype._clean = function() { var keys = Object.keys(Contract.Schema.properties); for (var field in this._properties) { if (keys.indexOf(field) === -1) { delete this._properties[field]; } } return this; }; /** * Validates the contract specification * @private * @returns {Boolean} validity */ Contract.prototype._validate = function() { return this._validator(this._properties); }; /** * Checks if the contract is complete * @returns {Boolean} completed */ Contract.prototype.isComplete = function() { for (var prop in this._properties) { if (this._properties[prop] === null) { return false; } } return true; }; /** * Returns the string representation of the contract, minus the signature * fields, sorted alphanumerically for signing and verifying * @private * @returns {String} */ Contract.prototype._getSigningData = function() { var sorted = this.toObject(); delete sorted.renter_signature; delete sorted.farmer_signature; return stringify(sorted); }; /** * Signs the contract as the given actor * @param {String} actor - One of 'farmer' or 'renter' * @param {Buffer} secret - ECDSA private key * @returns {String} signature */ Contract.prototype.sign = function(actor, secret) { var property = actor + '_signature'; var message = Message(this._getSigningData()); var signature = message.sign(bitcore.PrivateKey.fromString(secret)); return this.set(property, signature); }; /** * Verify the contract signature for the given actor * @param {String} actor - One of 'farmer' or 'renter' * @param {Buffer} pubkeyhash - ECDSA nodeID * @returns {Boolean} validity */ Contract.prototype.verify = function(actor, pubkeyhash) { if (!pubkeyhash) { return false; } var property = actor + '_signature'; var message = Message(this._getSigningData()); var address = bitcore.Address.fromPublicKeyHash(Buffer(pubkeyhash, 'hex')); return message.verify(address, this.get(property)); }; /** * Applies the provided fields to the contract and validates it * @param {Object} fields - Contract properties to update * @returns {Contract} self */ Contract.prototype.update = function(fields) { for (var prop in fields) { this.set(prop, fields[prop]); } return this; }; /** * Returns the value for the given contract property * @param {String} field_name - Contract property to get * @returns {String|Number|null} value */ Contract.prototype.get = function(field_name) { return this._properties[field_name]; }; /** * Sets the contract property to the given value * @param {String} field_name - Contract property to get * @returns {String|Number|null} value */ Contract.prototype.set = function(field_name, field_value) { this._properties[field_name] = field_value; this._clean(); assert.ok(this._validate(), 'Invalid contract property supplied'); return this._properties[field_name]; }; /** * Calculates the SHA-256 hash of the serialized contract * @returns {Buffer} */ Contract.prototype.getHash = function() { return crypto.createHash('sha256').update(this.toBuffer()).digest(); }; /** * Return OPCODE byte sequence for contract publication topic * @returns {Buffer} */ Contract.prototype.getTopicBuffer = function() { return Contract.createTopic(this._criteria); }; /** * Return OPCODE byte sequence for contract publication topic as hex string * @returns {String} */ Contract.prototype.getTopicString = function() { return this.getTopicBuffer().toString('hex'); }; /** * Converts the contract to a plain object * @returns {Object} */ Contract.prototype.toObject = function() { return JSON.parse(this.toJSON()); }; /** * Converts the contract to JSON string * @returns {String} */ Contract.prototype.toJSON = function() { return stringify(this._properties); }; /** * Converts the contract to Buffer * @returns {Buffer} */ Contract.prototype.toBuffer = function() { return new Buffer(this.toJSON(), 'utf8'); }; /** * Creates a contract from a plain object * @param {Object} object - Dictionary of contract data * @returns {Contract} */ Contract.fromObject = function(object) { return new Contract(object); }; /** * Creates a contract from a JSON string * @param {String} json - JSON encoded contract * @returns {Contract} */ Contract.fromJSON = function(json) { return new Contract(JSON.parse(json)); }; /** * Creates a contract from a Buffer * @param {Buffer} buffer - Raw binary blob of contract data * @returns {Contract} */ Contract.fromBuffer = function(buffer) { return new Contract(JSON.parse(buffer.toString('utf8'))); }; /** * Creates a validator function for data against the schema * @returns {Function} validator */ Contract.createValidator = function() { return JSONSchema(Contract.Schema); }; /** * Create a topical OPCODE byte sequence from the provided criteria * @param {Object} criteria * @param {Number} criteria.size - Criteria degree OPCODE * @param {Number} criteria.duration - Criteria degree OPCODE * @param {Number} criteria.availability - Criteria degree OPCODE * @param {Number} criteria.speed - Criteria degree OPCODE * @returns {Buffer} */ Contract.createTopic = function(criteria) { criteria = merge(Object.create(Contract.CRITERIA), criteria); return new Buffer([ constants.OPCODE_CONTRACT_PREFIX, criteria.size, criteria.duration, criteria.availability, criteria.speed ]); }; /** * Compares two contracts against each other * @param {Contract} c1 - Contract to compare * @param {Contract} c2 - Contract to compare * @returns {Boolean} */ Contract.compare = function(c1, c2) { var contract1 = c1.toObject(); var contract2 = c2.toObject(); var ignored = [ 'renter_id', 'renter_signature', 'farmer_id', 'farmer_signature', 'payment_destination' ]; ignored.forEach(function(prop) { delete contract1[prop]; delete contract2[prop]; }); return JSON.stringify(contract1) === JSON.stringify(contract2); }; module.exports = Contract; × Search results Close "},"lib_datachannel_client.js.html":{"id":"lib_datachannel_client.js.html","title":"Source: lib/datachannel/client.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/datachannel/client.js 'use strict'; var WebSocketClient = require('ws'); var stream = require('readable-stream'); var assert = require('assert'); var events = require('events'); var inherits = require('util').inherits; var url = require('url'); /** * Creates a data channel client for sending and receiving consigned file shards * @constructor * @param {Object} contact * @param {String} contact.address - The address of the target farmer * @param {Number} contact.port - The port of the target farmer */ function DataChannelClient(contact) { if (!(this instanceof DataChannelClient)) { return new DataChannelClient(contact); } assert.ok(contact, 'No contact was supplied to constructor'); assert(typeof contact.address === 'string', 'Invalid contact address'); assert(typeof contact.port === 'number', 'Invalid contact port'); events.EventEmitter.call(this); this._contact = contact; this._client = new WebSocketClient(DataChannelClient.getChannelURL(contact)); this._client.on('open', this._handleChannelOpen.bind(this)); this._client.on('error', this._handleChannelError.bind(this)); } inherits(DataChannelClient, events.EventEmitter); /** * Creates a readable stream from the remote farmer for retrieval of a shard * @param {String} token - The RETRIEVE token supplied by the farmer * @param {String} hash - The hash of the data to retrieve * @returns {stream.Readable} */ DataChannelClient.prototype.createReadStream = function(token, hash) { var self = this; var auth = false; var rstream = new stream.Readable({ read: function() { if (!auth) { return self._client.send(JSON.stringify({ token: token, hash: hash, operation: 'PULL' }), function() { auth = true; }); } } }); this._client.on('message', function(data) { if (!Buffer.isBuffer(data)) { try { data = JSON.parse(data); } catch (err) { rstream.emit('error', err); } if (data.code &amp;&amp; data.code !== 200) { rstream.emit('error', new Error(data.message)); } return this.close(); } rstream.push(data); }); this._client.on('close', function() { rstream.push(null); }); return rstream; }; /** * Creates a writable stream from the remote farmer for consignment of a shard * @param {String} token - The CONSIGN token supplied by the farmer * @param {String} hash - The hash of the data to consign * @returns {stream.Writable} */ DataChannelClient.prototype.createWriteStream = function(token, hash) { var self = this; var auth = false; var wstream = new stream.Writable({ write: function(chunk, encoding, next) { if (!auth) { return self._client.send(JSON.stringify({ token: token, hash: hash, operation: 'PUSH' }), function() { auth = true; self._client.send(chunk, { binary: true }, next); }); } self._client.send(chunk, { binary: true }, next); } }); this._client.on('message', function(data) { try { data = JSON.parse(data); } catch (err) { wstream.emit('error', err); } if (data.code &amp;&amp; data.code !== 200) { wstream.emit('error', new Error(data.message)); } this.close(); }); return wstream; }; /** * Handles the open event from the underlying client * @private */ DataChannelClient.prototype._handleChannelOpen = function() { this.emit('open'); }; /** * Handles the open event from the underlying client * @private */ DataChannelClient.prototype._handleChannelError = function(err) { this.emit('error', err); }; /** * Returns the URI of the contact's data channel * @static * @param {Object} contact */ DataChannelClient.getChannelURL = function(contact) { return url.format({ protocol: 'ws', slashes: true, hostname: contact.address, port: contact.port }); }; module.exports = DataChannelClient; × Search results Close "},"lib_datachannel_server.js.html":{"id":"lib_datachannel_server.js.html","title":"Source: lib/datachannel/server.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/datachannel/server.js 'use strict'; var ws = require('ws'); var PassThrough = require('readable-stream').PassThrough; var assert = require('assert'); var Manager = require('../manager'); var events = require('events'); var inherits = require('util').inherits; var ms = require('ms'); var crypto = require('crypto'); var utils = require('../utils'); /** * Creates a data channel server for sending and receiving consigned file shards * @constructor * @param {Object} options * @param {http.Server} options.server - A http(s).Server instance * @param {Manager} options.manager - The Manager from {@link Network} * @param {kad.Logger} options.logger - Logger to use from {@link Network} * @param {Number} options.ttl - Close after idle for this length of time */ function DataChannelServer(options) { if (!(this instanceof DataChannelServer)) { return new DataChannelServer(options); } this._checkOptions(options); events.EventEmitter.call(this); this._server = options.server; this._manager = options.manager; this._log = options.logger; this._ttl = options.ttl || ms('10m'); this._server = new ws.Server({ server: this._server }); this._allowed = {}; this._server.on('connection', this._handleConnection.bind(this)); this._server.on('error', this._handleError.bind(this)); } inherits(DataChannelServer, events.EventEmitter); /** * Begin accepting data for the given file hash and token * @param {String} token - The authorization token created for transfer * @param {String} filehash - The shard hash to allow for the token */ DataChannelServer.prototype.accept = function(token, filehash) { assert(typeof token === 'string', 'Invalid token supplied'); assert(typeof filehash === 'string', 'Invalid filehash supplied'); this._allowed[token] = { hash: filehash, client: null }; }; /** * Stop accepting data for the given token * @param {String} token - The authorization token created for transfer */ DataChannelServer.prototype.reject = function(token) { assert(typeof token === 'string', 'Invalid token supplied'); if (this._allowed[token] &amp;&amp; this._allowed[token].client) { var client = this._allowed[token].client; if ([ws.CONNECTING, ws.OPEN].indexOf(client.readyState) !== -1) { this._allowed[token].client.close(); } } delete this._allowed[token]; }; /** * Closes the data channel and disconnects all clients */ DataChannelServer.prototype.close = function() { return this._server.close(); }; /** * Checks the options supplied to constructor * @private */ DataChannelServer.prototype._checkOptions = function(options) { assert.ok(options, 'No options were supplied to constructor'); assert(options.manager instanceof Manager, 'Invalid manager supplied'); assert.ok(options.logger, 'Invalid logger supplied'); }; /** * Handles incoming connections * @private * @param {Socket} socket - The connected socket object */ DataChannelServer.prototype._handleConnection = function(socket) { var self = this; var token = null; this._log.info('data channel connection opened'); this.emit('connection', socket); socket.on('error', function(err) { self._log.error('data channel connection error: %s', err.message); socket.close(500, err.message); }); socket.on('message', function(data) { try { data = JSON.parse(data); } catch (err) { return socket.close(400, 'Failed to parse message'); } token = data.token; try { self._authorize(token, data.hash); } catch (err) { return socket.close(401, err.message); } self._allowed[token].client = socket; socket.removeAllListeners('message'); switch (data.operation) { case 'PUSH': return self._handleConsignStream(socket, token); case 'PULL': return self._handleRetrieveStream(socket, token); default: return self._handleUnknownStream(socket, token); } }); }; /** * Validates the given token * @private */ DataChannelServer.prototype._authorize = function(token, hash) { var self = this; assert.ok(token, 'You did not supply a token'); assert.ok(self._allowed[token], 'The supplied token is not accepted'); assert.ok(hash, 'You did not supply the data hash'); assert(self._allowed[token].client === null, 'Channel is already active'); assert(self._allowed[token].hash === hash, 'Token not valid for hash'); }; /** * Receives the data stream and writes it to storage * @private * @param {stream.Readable} socket - The connected socket * @param {String} token - The valid channel token */ DataChannelServer.prototype._handleConsignStream = function(socket, token) { var self = this; var hasher = crypto.createHash('sha256'); var hash = this._allowed[token].hash; var passthrough = new PassThrough(); var received = 0; passthrough.pause(); socket.on('message', function(data) { received += data.length; passthrough.write(data); }); this._manager.load(hash, function(err, item) { if (err) { socket.close(500, err.message); return self.reject(token); } var contract = Object.keys(item.contracts)[0]; var shardsize = item.contracts[contract].get('data_size'); if (socket.readyState !== ws.OPEN) { return self.reject(token); } socket.resume(); // If the shard is not writable, it means we already have it, so let's // just respond with a success message if (typeof item.shard.write !== 'function') { return self._closeSocketSuccess(socket, 'Consignment completed', token); } passthrough.on('data', function(chunk) { hasher.update(chunk); item.shard.write(chunk); if (received &gt;= shardsize) { passthrough.end(); } }).resume(); passthrough.on('end', function() { if (utils.rmd160(hasher.digest('hex')) !== hash) { socket.close(400, 'Calculated hash does not match the expected result'); return self.reject(token); } item.shard.end(); self._closeSocketSuccess(socket, 'Consignment completed', token); }); }); }; /** * Pumps the data through to the client * @private * @param {stream.Readable} socket - The incoming data stream * @param {String} token - The valid channel token */ DataChannelServer.prototype._handleRetrieveStream = function(socket, token) { var self = this; var hash = this._allowed[token].hash; this._manager.load(hash, function(err, item) { if (err) { socket.close(500, err.message); return self.reject(token); } var filestream = item.shard; filestream.on('data', function(data) { filestream.pause(); if (socket.readyState !== ws.OPEN) { filestream.removeAllListeners(); return self.reject(token); } socket.send(data, { binary: true }, function() { filestream.resume(); }); }); filestream.on('end', function() { self._closeSocketSuccess(socket, 'File transfer complete', token); }); }); }; /** * Closes the stream if it cannot be handled * @private * @param {stream.Readable} stream - The incoming data stream * @param {String} token - The valid channel token */ DataChannelServer.prototype._handleUnknownStream = function(stream, token) { var client = this._allowed[token].client; client.close(400, 'Failed to handle the defined operation'); this.reject(token); }; /** * Handles binary server errors * @private * @param {Error} err - The error object */ DataChannelServer.prototype._handleError = function(err) { this._log.error('data channel server encountered an error: %s', err.message); this.emit('error', err); }; /** * Sends a success message for operation and rejects the token * @private */ DataChannelServer.prototype._closeSocketSuccess = function(sock, msg, token) { sock.send(JSON.stringify({ code: 200, message: msg })); this.reject(token); }; module.exports = DataChannelServer; × Search results Close "},"lib_cipherkeyiv.js.html":{"id":"lib_cipherkeyiv.js.html","title":"Source: lib/cipherkeyiv.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/cipherkeyiv.js 'use strict'; var crypto = require('crypto'); var utils = require('./utils'); /** * Create a new random cipher key and initialization vector * @constructor * @param {String|Buffer} password - The unique cipher password * @param {String|Buffer} salt - The unique salt */ function DataCipherKeyIv(pass, salt) { if (!(this instanceof DataCipherKeyIv)) { return new DataCipherKeyIv(pass, salt); } if (!pass &amp;&amp; !salt) { pass = crypto.randomBytes(DataCipherKeyIv.PASS_BYTES); salt = crypto.randomBytes(DataCipherKeyIv.SALT_BYTES); } this._pass = Buffer.isBuffer(pass) ? pass : Buffer(pass, 'hex'); this._salt = Buffer.isBuffer(salt) ? salt : Buffer(salt, 'hex'); this._pbkdf2 = crypto.pbkdf2Sync( this._pass, this._salt, 25000, 512, 'sha512' ); } DataCipherKeyIv.PASS_BYTES = 512; DataCipherKeyIv.SALT_BYTES = 32; /** * Returns the cipher key and iv in an array * @returns {Array} */ DataCipherKeyIv.prototype.getCipherKeyIv = function() { return [ Buffer(utils.sha256(this._pbkdf2), 'hex'), Buffer(utils.rmd160(this._salt), 'hex').slice(0, 16) ]; }; /** * Returns the key and iv as an array * @returns {Array} */ DataCipherKeyIv.prototype.toObject = function() { return { pass: this._pass.toString('hex'), salt: this._salt.toString('hex') }; }; /** * Returns the a {@link DataCipherKeyIv} from an object * @param {Object} object * @param {Buffer|String} object.pass - The unique password * @param {Buffer|String} object.salt - The unique salt * @returns {DataCipherKeyIv} */ DataCipherKeyIv.fromObject = function(object) { return new DataCipherKeyIv(object.pass, object.salt); }; module.exports = DataCipherKeyIv; × Search results Close "},"lib_cryptostream_decrypt.js.html":{"id":"lib_cryptostream_decrypt.js.html","title":"Source: lib/cryptostream/decrypt.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/cryptostream/decrypt.js 'use strict'; var constants = require('../constants'); var inherits = require('util').inherits; var assert = require('assert'); var crypto = require('crypto'); var DataCipherKeyIv = require('../cipherkeyiv'); /** * Represents a duplex stream capable of taking encrypted data as input and * producing output decrypted by a {@link DataCipherKeyIv} * @constructor * @param {DataCipherKeyIv} keyiv - Object to use for derivation function * @emits DecryptStream#data * @emits DecryptStream#end */ function DecryptStream(keyiv) { if (!(this instanceof DecryptStream)) { return new DecryptStream(keyiv); } assert(keyiv instanceof DataCipherKeyIv, 'Invalid cipher object supplied'); this.keyiv = keyiv; crypto.Decipheriv.apply(this, [constants.CIPHER_ALG].concat( keyiv.getCipherKeyIv() )); } /** * Triggered when some input bytes have become decrypted output bytes * @event DecryptStream#data * @type {Buffer} */ /** * Triggered when the stream has ended * @event DecryptStream#end */ inherits(DecryptStream, crypto.Decipheriv); module.exports = DecryptStream; × Search results Close "},"lib_cryptostream_encrypt.js.html":{"id":"lib_cryptostream_encrypt.js.html","title":"Source: lib/cryptostream/encrypt.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/cryptostream/encrypt.js 'use strict'; var constants = require('../constants'); var inherits = require('util').inherits; var assert = require('assert'); var crypto = require('crypto'); var DataCipherKeyIv = require('../cipherkeyiv'); /** * Represents a duplex stream capable of taking cleartext data as input and * producing output encrypted with {@link DataCipherKeyIv} * @constructor * @param {DataCipherKeyIv} keyiv - Object to use for derivation function * @emits EncryptStream#data * @emits EncryptStream#end */ function EncryptStream(keyiv) { if (!(this instanceof EncryptStream)) { return new EncryptStream(keyiv); } assert(keyiv instanceof DataCipherKeyIv, 'Invalid cipher object supplied'); this.keyiv = keyiv; crypto.Cipheriv.apply(this, [constants.CIPHER_ALG].concat( keyiv.getCipherKeyIv() )); } /** * Triggered when some input bytes have become encrypted output bytes * @event EncryptStream#data * @type {Buffer} */ /** * Triggered when the stream has ended * @event EncryptStream#end */ inherits(EncryptStream, crypto.Cipheriv); module.exports = EncryptStream; × Search results Close "},"lib_interfaces_farmer.js.html":{"id":"lib_interfaces_farmer.js.html","title":"Source: lib/interfaces/farmer.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/interfaces/farmer.js 'use strict'; var async = require('async'); var path = require('path'); var kad = require('kad'); var Network = require('../network'); var inherits = require('util').inherits; var StorageItem = require('../storage/item'); var Contract = require('../contract'); var merge = require('merge'); var constants = require('../constants'); var Manager = require('../manager'); var LevelDBStorageAdapter = require('../storage/adapters/level'); var utils = require('../utils'); /** * Creates and a new farmer interface * @constructor * @extends {Network} * @param {Object} options * @param {Object} options.storage * @param {String} options.storage.path - File system path to store data * @param {Number} options.storage.size - Storage size to allocate * @param {String} options.storage.unit - Storage size unit (MB|GB|TB) * @param {Object} options.payment * @param {String} options.payment.address - Optional payment address * @param {Array} options.opcodes - Optional contract opcodes to farm * @param {Function} options.backend - Optional levelup backend db * @param {Number} options.concurrency - Max contracts to offer at a time * @param {FarmerInterface~negotiator} options.negotiator - Negotiation rules */ function FarmerInterface(options) { if (!(this instanceof FarmerInterface)) { return new FarmerInterface(options); } options = merge.recursive(Object.create(FarmerInterface.DEFAULTS), options); options.manager = new Manager( LevelDBStorageAdapter( path.join(options.storage.path, 'farmer.db'), options.backend ), { maxCapacity: utils.toNumberBytes(options.storage.size, options.storage.unit) }); this._hasFreeSpace = true; this._negotiator = options.negotiator; this._pendingOffers = []; this._subscribed = []; Network.call(this, options); this._listenForCapacityChanges(options.manager); } inherits(FarmerInterface, Network); /** * Called when a contract is found that meets subscription criteria and allows * us to modify the contract terms if we desire and then uses the return value * to determine if we should send the renter an offer * @callback FarmerInterface~negotiator * @param {Contract} contract - The contract object to negotiate * @returns {Boolean} */ FarmerInterface.DEFAULTS = { storage: { path: '/tmp/storj-farmer', size: 5, unit: 'MB' }, payment: { address: '' }, opcodes: ['0f01020202', '0f02020202', '0f03020202'], negotiator: function(/* contract */) { return true; }, concurrency: constants.MAX_CONCURRENT_OFFERS }; /** * Wraps the super call to {@link Network#join} to listen for contract after * successfully establishing a connection to the network * @param {Function} callback - Called on successful join */ FarmerInterface.prototype.join = function(callback) { var self = this; Network.prototype.join.call(this, function(err) { if (err) { return callback(err); } self._listenForContracts(self._options.opcodes); callback(); }); }; /** * Sends the given contract as an offer to the specified renter * @private * @param {Contract} contract - The contract to include in offer * @param {Contact} renter - The renter who originally published the contract */ FarmerInterface.prototype._sendOfferForContract = function(contract, contact) { var self = this; var message = new kad.Message({ method: 'OFFER', params: { contract: contract.toObject(), contact: self._contact } }); self._transport.send(contact, message, function(err, response) { self._removeContractFromPendingList(contract); if (err) { return self._logger.error(err.message); } if (response.error || !response.result.contract) { return self._logger.error( response.error ? response.error.message : 'Renter refused to sign' ); } self._handleOfferRes(response, contract, contact); }); }; /** * Returns the payment address supplied or the derived one from keypair * @returns {String} */ FarmerInterface.prototype.getPaymentAddress = function() { return this._options.payment.address || this._keypair.getAddress(); }; /** * Handles a received contract and negotiates storage * @private * @param {Contract} contract */ FarmerInterface.prototype._negotiateContract = function(contract) { var self = this; contract.set('farmer_id', self._keypair.getNodeID()); contract.set('payment_destination', self.getPaymentAddress()); contract.sign('farmer', self._keypair.getPrivateKey()); var item = new StorageItem({ hash: contract.get('data_hash') }); var renterId = contract.get('renter_id'); item.contracts[renterId] = contract.toObject(); item.meta[renterId] = {}; self._manager.save(item, function(err) { if (err) { self._removeContractFromPendingList(contract); return self._logger.error(err.message); } if (self._router.getContactByNodeID(renterId)) { return self._sendOfferForContract( contract, self._router.getContactByNodeID(renterId) ); } self._router.findNode(renterId, function(err, nodes) { if (err) { self._removeContractFromPendingList(contract); return self._logger.error(err.message); } var renter = nodes.filter(function(node) { return node.nodeID === renterId; })[0]; if (!renter) { self._removeContractFromPendingList(contract); return self._logger.error('Could not locate renter for offer'); } self._sendOfferForContract(contract, renter); }); }); }; /** * Checks if we should send an offer by checking the pending offers and running * the optional custom negotiator function * @private * @param {Contract} contract * @returns {Boolean} */ FarmerInterface.prototype._shouldSendOffer = function(contract) { return (this._pendingOffers.length &lt; this._options.concurrency) &amp;&amp; (this._negotiator(contract) === true) &amp;&amp; this._hasFreeSpace; }; /** * Adds the contract data hash to the pending offers list * @private * @param {Contract} contract - The contract being negotiated */ FarmerInterface.prototype._addContractToPendingList = function(contract) { var id = contract.get('data_hash') + contract.get('renter_id'); if (this._pendingOffers.indexOf(id) !== -1) { return 0; } return this._pendingOffers.push(id); }; /** * Removes the contract data hash to the pending offers list * @param {Contract} contract - The contract being negotiated * @private */ FarmerInterface.prototype._removeContractFromPendingList = function(contract) { var index = this._pendingOffers.indexOf( contract.get('data_hash') + contract.get('renter_id') ); if (index === -1) { return; } this._pendingOffers.splice(index, 1); }; /** * Handles an offer response from a renter * @private */ FarmerInterface.prototype._handleOfferRes = function(res, contract, renter) { var self = this; var final = null; try { final = Contract.fromObject(res.result.contract); } catch (err) { return self._logger.error('Renter responded with invalid contract'); } if (!final.verify('renter', contract.get('renter_id'))) { return self._logger.error('Renter signature is invalid'); } self._manager.load(contract.get('data_hash'), function(err, item) { if (err) { item = new StorageItem({ hash: contract.get('data_hash') }); } item.contracts[renter.nodeID] = contract.toObject(); item.meta[renter.nodeID] = {}; self._manager.save(item, function() {}); }); }; /** * Subscribes to a contract identifier on the network * @private * @param {Array} opcodes */ FarmerInterface.prototype._listenForContracts = function(opcodes) { var self = this; async.eachSeries(opcodes.filter(function(opcode) { return self._subscribed.indexOf(opcode) === -1; }), function(opcode, next) { self.subscribe(opcode, self._handleContractPublication.bind(self)); setTimeout(next, constants.SUBSCRIBE_THROTTLE); }); self._subscribed = self._subscribed.concat(opcodes); }; /** * Updates the internal tracker of free space * @private * @param {Manager} manager = The storage manager passed to the interface */ FarmerInterface.prototype._listenForCapacityChanges = function(manager) { var self = this; manager.on('locked', function() { self._hasFreeSpace = false; }); manager.on('unlocked', function() { self._hasFreeSpace = true; }); manager.on('error', function(err) { self._logger.error('Error is storage manager: %s', err.message); }); }; /** * Handles received contract publications * @private * @param {Object} contract - The raw contract object */ FarmerInterface.prototype._handleContractPublication = function(contract) { var contractObj; try { contractObj = Contract.fromObject(contract); } catch (err) { return false; // If the contract is invalid just drop it } if (!this._shouldSendOffer(contractObj)) { return false; } this._addContractToPendingList(contractObj); this._negotiateContract(contractObj); return true; }; module.exports = FarmerInterface; × Search results Close "},"lib_network_index.js.html":{"id":"lib_network_index.js.html","title":"Source: lib/network/index.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/index.js 'use strict'; var url = require('url'); var assert = require('assert'); var merge = require('merge'); var async = require('async'); var kad = require('kad'); var bitcore = require('bitcore-lib'); var constants = require('../constants'); var Message = require('bitcore-message'); var Quasar = require('kad-quasar').Protocol; var utils = require('../utils'); var KeyPair = require('../keypair'); var Manager = require('../manager'); var Protocol = require('./protocol'); var Contact = require('./contact'); var Transport = require('./transport'); var DataChannelServer = require('../datachannel/server'); var TunnelClient = require('../tunnel/client'); var EventEmitter = require('events').EventEmitter; var inherits = require('util').inherits; var RateLimiter = require('./ratelimiter'); var ms = require('ms'); var BridgeClient = require('../bridgeclient'); /** * Storj network interface * @constructor * @param {Object} options * @param {KeyPair} options.keypair - Node's cryptographic identity * @param {Manager} options.manager - Persistence management interface * @param {String} options.bridge - URL for bridge server seed lookup * @param {Object} options.logger - Logger instance * @param {Array} options.seeds - List of seed URIs to join * @param {String} options.address - Public node IP or hostname * @param {Number} options.port - Listening port for RPC * @param {Boolean} options.noforward - Flag for skipping traversal strategies * @param {Number} options.tunnels - Max number of tunnels to provide * @param {Number} options.tunport - Port for tunnel server to use * @param {Object} options.gateways * @param {Number} options.gateways.min - Min port for gateway binding * @param {Number} options.gateways.max - Max port for gateway binding * @param {Object} options.limiter - Options to pass to {@link RateLimiter} * @emits Network#ready */ function Network(options) { if (!(this instanceof Network)) { return new Network(options); } this._pendingContracts = {}; this._keypair = options.keypair; this._manager = options.manager; this._tunnelers = kad.Bucket(); this._options = this._checkOptions(options); this._logger = options.logger; this._storage = new kad.storage.MemStore(); this._pubkeys = {}; this._open = false; this._initNetworkInterface(); } inherits(Network, EventEmitter); /** * Ready event is triggered when the transport's network interface is ready * @event Network#ready */ Network.DEFAULTS = { bridge: 'https://api.storj.io', seeds: [], address: '127.0.0.1', port: 4000, noforward: false, tunnels: 3, tunport: 0, // NB: Pick random open port gateways: { min: 0, max: 0 } // NB: Port range for gatways - default any }; /** * Check the options supplied to the constructor * @private */ Network.prototype._checkOptions = function(options) { assert(options.keypair instanceof KeyPair, 'Invalid keypair supplied'); assert(options.manager instanceof Manager, 'Invalid manager supplied'); assert.ok(this._validateLogger(options.logger), 'Invalid logger supplied'); return merge(Object.create(Network.DEFAULTS), options); }; /** * Validates the logger object supplied * @private */ Network.prototype._validateLogger = function(logger) { return logger &amp;&amp; logger.debug &amp;&amp; logger.warn &amp;&amp; logger.info &amp;&amp; logger.error; }; /** * Opens the connection to the network * @param {Function} callback - Called on successful network join */ Network.prototype.join = function(callback) { var self = this; if (!this._ready) { return this.once('ready', this.join.bind(this, callback)); } this._transport.on('error', this._handleTransportError.bind(this)); this._transport.before('serialize', this._signMessage.bind(this)); this._transport.before('receive', this._verifyMessage.bind(this)); this._transport.before('receive', this._checkRateLimiter.bind(this)); this._transport.before('receive', kad.hooks.protocol( this._protocol.handlers() )); this._node = new kad.Node({ transport: this._transport, router: this._router, storage: this._storage, logger: this._logger }); function onJoinComplete(err) { if (self._transport._isPublic) { self._listenForTunnelers(); } callback(err, self); } this._setupTunnelClient(function(err) { if (err) { return callback(err); } self._enterOverlay(onJoinComplete); }); }; /** * Iteratively attempt connection to network via supplied seeds * @private */ Network.prototype._enterOverlay = function(callback) { var self = this; function _trySeeds() { async.detectSeries(self._options.seeds, function(uri, next) { self._logger.info('attemting to join network via %s', uri); self.connect(uri, function(err) { if (err) { self._logger.warn('failed to connect to seed %s', uri); } else { self._logger.info('connected to the storj network via %s', uri); } next(null, !err); }); }, callback); } if (this._options.seeds.length) { return _trySeeds(); } if (this._options.bridge === false) { self._logger.warn('no bridge or seeds provided, not connected'); return callback(null); } this._logger.info('resolving seeds from %s', this._options.bridge); this._bridge.getContactList({ connected: true }, function(err, seeds) { if (err) { return callback( new Error('Failed to discover seeds from bridge: ' + err.message) ); } self._options.seeds = seeds.map(utils.getContactURL); _trySeeds(); }); }; /** * Disconnects from the network * @param {Function} callback - Called when successful disconnect */ Network.prototype.leave = function(callback) { this._node.disconnect(callback); }; /** * Publishes a topic with content to the network * @param {String} topic - The serialized opcode topic * @param {Object} contents - Arbitrary publication contents * @param {Object} options - Options to pass to kad-quasar */ Network.prototype.publish = function(topic, contents, options) { return this._pubsub.publish(topic, contents, options); }; /** * Subscribes to a topic on the network * @param {String} topic - The serialized opcode topic * @param {Object} handler - Function to handle received publications */ Network.prototype.subscribe = function(topic, handler) { return this._pubsub.subscribe(topic, handler); }; /** * Connects to the node at the given URI * @param {String} uri - The storj protocol URI to connect * @param {Function} callback - Called on connection or error */ Network.prototype.connect = function(uri, callback) { return this._node.connect(this._createContact(uri), callback); }; /** * Returns a Storj contact from the URI * @private * @param {String} uri */ Network.prototype._createContact = function(uri) { var parsed = url.parse(uri); return new Contact({ address: parsed.hostname, port: Number(parsed.port), nodeID: parsed.path.substr(1) }); }; /** * Initilizes the network interface * @private */ Network.prototype._initNetworkInterface = function() { EventEmitter.call(this); this._bridge = new BridgeClient(this._options.bridge); this._protocol = new Protocol({ network: this }); this._contact = new Contact({ address: this._options.address, port: this._options.port, nodeID: this._keypair.getNodeID() }); this._transport = new Transport(this._contact, { logger: this._logger, cors: true, tunnels: this._options.tunnels, tunport: this._options.tunport, gateways: this._options.gateways, noforward: this._options.noforward }); this._router = new kad.Router({ transport: this._transport, logger: this._logger }); this._pubsub = new Quasar(this._router, { logger: this._logger }); this._limiter = new RateLimiter(this._options.limiter); this._transport.after('open', this._onTransportOpen.bind(this)); }; /** * Checks the rate limiter and updates it appropriately * @private */ Network.prototype._checkRateLimiter = function(message, contact, next) { if (kad.Message.isResponse(message)) { return next(); // NB: Ignore rate limiter if this is a response message } if (!this._limiter.isLimited(contact.nodeID)) { this._limiter.updateCounter(contact.nodeID); return next(); } var timeLeft = ms(this._limiter.getResetTime()); var response = new kad.Message({ id: message.id, result: {}, error: new Error('Rate limit exceeded, please wait ' + timeLeft) }); this._transport.send(contact, response); }; /** * Set up {@link DataChannelServer} after transport is ready * @private */ Network.prototype._onTransportOpen = function() { this._ready = true; this._channel = new DataChannelServer({ server: this._transport._server, manager: this._manager, logger: this._logger }); this.emit('ready'); }; /** * Signs an outgoing message * @private * @param {kad.Message} message * @param {Function} callback */ Network.prototype._signMessage = function(message, callback) { var nonce = Date.now(); var target = message.id + nonce; var signature = this._keypair.sign(target); if (kad.Message.isRequest(message)) { message.params.nonce = nonce; message.params.signature = signature; } else { message.result.nonce = nonce; message.result.signature = signature; } callback(); }; /** * Verifies an incoming message * @private * @param {kad.Message} message * @param {Contact} contact * @param {Function} callback */ Network.prototype._verifyMessage = function(message, contact, callback) { if (!utils.isCompatibleVersion(contact.protocol)) { this._router.removeContact(contact); return callback(new Error('Protocol version is incompatible')); } var messagekey = kad.Message.isRequest(message) ? 'params' : 'result'; var nonce = message[messagekey].nonce; var signature = message[messagekey].signature; if (Date.now() &gt; (constants.NONCE_EXPIRE + nonce)) { return callback(new Error('Message signature expired')); } var addr = bitcore.Address.fromPublicKeyHash(Buffer(contact.nodeID, 'hex')); var signobj = this._createSignatureObject(signature); this._verifySignature({ message: message, nonce: nonce, signobj: signobj, address: addr, contact: contact, signature: signature }, callback); }; /** * Verifies the validity of the supplied signature * @private */ Network.prototype._verifySignature = function(options, callback) { if (!options.signobj) { return callback(new Error('Invalid signature supplied')); } var signedmsg = Message(options.message.id + options.nonce); var ecdsa = new bitcore.crypto.ECDSA(); ecdsa.hashbuf = signedmsg.magicHash(); ecdsa.sig = options.signobj; this._pubkeys[options.contact.nodeID] = ecdsa.toPublicKey(); if (!signedmsg.verify(options.address, options.signature)) { return callback(new Error('Signature verification failed')); } callback(); }; /** * Creates a signature object from signature string * @private */ Network.prototype._createSignatureObject = function(signature) { var compactSig; var signobj; try { compactSig = new Buffer(signature, 'base64'); signobj = bitcore.crypto.Signature.fromCompact(compactSig); } catch (err) { return null; } return signobj; }; /** * Proxies error events from the underlying transport adapter * @private * @param {Error} error */ Network.prototype._handleTransportError = function(error) { this._logger.error(error.message); }; /** * Subscribe to tunneler opcodes to manage known tunnelers * @private */ Network.prototype._listenForTunnelers = function() { var self = this; var tunserver = self._transport._tunserver; var prefix = Buffer([constants.OPCODE_TUNNELER_PREFIX], 'hex'); var available = Buffer([constants.OPCODE_DEG_LOW], 'hex'); var unavailable = Buffer([constants.OPCODE_DEG_NULL], 'hex'); function announce() { self._pubsub.publish( Buffer.concat([ prefix, tunserver.hasTunnelAvailable() ? available : unavailable ]).toString('hex'), self._contact ); setTimeout(announce, constants.TUNNEL_ANNOUNCE_INTERVAL); } if (this._options.tunnels) { announce(); } this._transport._tunserver.on('locked', function() { self._pubsub.publish( Buffer.concat([prefix, unavailable]).toString('hex'), self._contact ); }); this._transport._tunserver.on('unlocked', function() { self._pubsub.publish( Buffer.concat([prefix, available]).toString('hex'), self._contact ); }); this._pubsub.subscribe( Buffer.concat([prefix, available]).toString('hex'), function(contact) { if (self._tunnelers.getSize() &lt; kad.constants.K) { self._tunnelers.addContact(Contact(contact)); } } ); this._pubsub.subscribe( Buffer.concat([prefix, unavailable]).toString('hex'), function(contact) { self._tunnelers.removeContact(Contact(contact)); } ); }; /** * Determines if tunnel is needed * @private * @param {Function} callback */ Network.prototype._setupTunnelClient = function(callback) { var self = this; if (this._transport._isPublic) { return callback(null); } function _discoverIfReachable() { self._logger.info('requesting probe from nearest neighbor'); self._requestProbe(neighbor, function(err, result) { if (err || result.error) { return self._findTunnel(neighbor, callback); } self._logger.info( 'you are publicly reachable, skipping tunnel establishment' ); self._listenForTunnelers(); callback(null); }); } var neighbor = this._options.seeds.length ? this._createContact(this._options.seeds[0]) : null; if (!neighbor) { if (this._options.bridge === false) { return callback( new Error('Could not find a neighbor to query for probe') ); } return this._bridge.getInfo(function(err, result) { if (err) { return callback(new Error('Failed to get seeds for probe')); } neighbor = self._createContact(result.info['x-network-seeds'][0]); _discoverIfReachable(); }); } _discoverIfReachable(); }; /** * Requests a probe from the nearest neighbor * @private */ Network.prototype._requestProbe = function(neighbor, callback) { var message = new kad.Message({ method: 'PROBE', params: { contact: this._contact } }); this._transport.send(neighbor, message, callback); }; /** * Finds a potential tunneler * @private * @param {Function} callback */ Network.prototype._findTunnel = function(neighbor, callback) { var self = this; var message = new kad.Message({ method: 'FIND_TUNNEL', params: { contact: this._contact, relayers: [] } }); if (!neighbor) { return callback( new Error('Could not find a neighbor to query for tunnels') ); } this._logger.info('requesting tunnelers from nearest neighbor'); this._transport.send(neighbor, message, function(err, resp) { if (err) { return callback( new Error('Failed to find tunnels, reason: ' + err.message) ); } self._establishTunnel(resp.result.tunnels, callback); }); }; /** * Creates a tunnel to a public node * @private * @param {Function} callback */ Network.prototype._establishTunnel = function(tunnels, callback) { var self = this; var tunnel = null; var alias = null; function established() { return tunnel &amp;&amp; alias; } function openTunnel(done) { if (!tunnels.length) { return done(new Error('No tunnelers were returned')); } var tun = new Contact(tunnels[0]); var msg = kad.Message({ method: 'OPEN_TUNNEL', params: { contact: self._contact } }); tunnels.shift(); self._transport.send(tun, msg, function(err, resp) { if (err) { return done(); } tunnel = resp.result.tunnel; alias = resp.result.alias; done(); }); } async.until(established, openTunnel, function(err) { if (err) { return callback( new Error('Failed to establish tunnel, reason: ' + err.message) ); } var local = 'http://127.0.0.1:' + self._transport._server.address().port; var tunclient = new TunnelClient(tunnel, local); tunclient.on('open', function() { self._logger.info('tunnel successfully established: %j', alias); self._contact.address = alias.address; self._contact.port = alias.port; self._listenForTunnelers(); callback(); }); tunclient.on('close', function onTunnelClosed(code, message) { self._logger.warn( 'tunnel connection closed: %s / %s', code, message ); self._establishTunnel(tunnels, callback); }); tunclient.on('error', function onTunnelError(err) { self._logger.warn( 'tunnel connection lost, reason: %s', err.message ); self._establishTunnel(tunnels, callback); }); tunclient.open(); }); }; module.exports = Network; × Search results Close "},"lib_filedemuxer.js.html":{"id":"lib_filedemuxer.js.html","title":"Source: lib/filedemuxer.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/filedemuxer.js 'use strict'; var inherits = require('util').inherits; var assert = require('assert'); var stream = require('readable-stream'); var fs = require('fs'); var EventEmitter = require('events').EventEmitter; var merge = require('merge'); /** * Takes a single file read stream and outputs several output streams, used for * &quot;shredding&quot; a file and creating muliple out destination interfaces * @constructor * @param {String} filePath - Path the file to demultiplex * @param {Object} options * @param {Number} options.shardSize - Size of each shard * @fires FileDemuxer#shard */ function FileDemuxer(filePath, options) { if (!(this instanceof FileDemuxer)) { return new FileDemuxer(filePath, options); } assert(fs.existsSync(filePath), 'File does not exist at the supplied path'); options = merge(Object.create(FileDemuxer.DEFAULTS), options); this._fileSize = fs.statSync(filePath).size; this._filePosition = 0; this._shardSize = options.shardSize; this._source = fs.createReadStream(filePath); this._currentShardIndex = 0; EventEmitter.call(this); setImmediate(this._openStream.bind(this)); } FileDemuxer.DEFAULTS = { shardSize: 1024 * 1024 * 8 }; /** * Triggered when the demuxer has a shard ready to stream * @event FileDemuxer#shard * @param {ReadableStream} shard - The file shard as a readable stream */ /** * Triggered when the demuxer has finished writing to all shards * @event FileDemuxer#finish */ inherits(FileDemuxer, EventEmitter); /** * Opens the underyling readable stream * @private */ FileDemuxer.prototype._openStream = function() { this._source.on('data', this._handleSourceBytes.bind(this)); this._source.on('end', this._handleSourceEnded.bind(this)); }; /** * Handles incoming data from the source stream * @private */ FileDemuxer.prototype._handleSourceBytes = function(chunk) { if (!this._currentOutput) { this._currentOutput = new stream.Readable({ read: function noop() {} }); this.emit('shard', this._currentOutput, this._currentShardIndex); } if (this._needsNewOutputStream()) { this._closeCurrentOutput(); this._currentOutput = new stream.Readable({ read: function noop() {} }); this.emit('shard', this._currentOutput, ++this._currentShardIndex); } setImmediate(this._pushBytesToOutput.bind(this, chunk)); }; /** * Closes the current output source and emits a finish event * @private */ FileDemuxer.prototype._handleSourceEnded = function() { this._closeCurrentOutput(); this.emit('finish'); }; /** * Simply pushes the given bytes to the current output * @private */ FileDemuxer.prototype._pushBytesToOutput = function(bytes) { if (bytes) { this._filePosition += bytes.length; } this._currentOutput.push(bytes); }; /** * Simply closes the output stream * @private */ FileDemuxer.prototype._closeCurrentOutput = function() { this._pushBytesToOutput(null); }; /** * Returns a boolean indicating if we should create a new shard stream * @private */ FileDemuxer.prototype._needsNewOutputStream = function() { var expectedIndex = Math.floor(this._filePosition / this._shardSize); return this._currentShardIndex &lt; expectedIndex; }; module.exports = FileDemuxer; × Search results Close "},"lib_filemuxer.js.html":{"id":"lib_filemuxer.js.html","title":"Source: lib/filemuxer.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/filemuxer.js 'use strict'; var assert = require('assert'); var stream = require('readable-stream'); var inherits = require('util').inherits; /** * Accepts multiple ordered input sources and exposes them as a single * contiguous readable stream. Used for re-assembly of shards. * @constructor * @param {Object} options * @param {Number} options.shards - Number of total shards to be multiplexed * @param {Number} options.length - Number of total bytes of input * @fires FileMuxer#drain */ function FileMuxer(options) { if (!(this instanceof FileMuxer)) { return new FileMuxer(options); } this._checkOptions(options); this._shards = options.shards; this._length = options.length; this._inputs = []; this._bytesRead = 0; this._added = 0; stream.Readable.call(this); } /** * Triggered when the muxer has drained one of the supplied inputs * @event FileMuxer#drain * @param {ReadableStream} input - The drained input stream */ inherits(FileMuxer, stream.Readable); /** * Checks the options supplied to the constructor * @private */ FileMuxer.prototype._checkOptions = function(options) { var shards = options.shards; var length = options.length; assert(typeof shards === 'number', 'You must supply a shards parameter'); assert(shards &gt; 0, 'Cannot multiplex a 0 shard stream'); assert(typeof length === 'number', 'You must supply a length parameter'); assert(length &gt; 0, 'Cannot multiplex a 0 length stream'); }; /** * Implements the underlying read method * @private */ FileMuxer.prototype._read = function() { var self = this; if (this._bytesRead === this._length) { return this.push(null); } if (!this._inputs[0]) { return this.emit('error', new Error('Unexpected end of input')); } var bytes = this._inputs[0].read(); if (bytes === null &amp;&amp; this._bytesRead &lt; this._length) { return setImmediate(function() { self._read(); }); } if (this._length &lt; this._bytesRead + bytes.length) { return this.emit('error', new Error('Input exceeds the declared length')); } this._bytesRead += bytes.length; this.push(bytes); }; /** * Adds an additional input stream to the multiplexer * @param {ReadableStream} readable - Readable input stream from file shard */ FileMuxer.prototype.input = function(readable) { assert(typeof readable.pipe === 'function', 'Invalid input stream supplied'); assert(this._added &lt; this._shards, 'Inputs exceed defined number of shards'); var self = this; var input = readable.pipe(stream.PassThrough()).pause(); input.on('end', function() { self._inputs.splice(self._inputs.indexOf(input), 1); self.emit('drain', input); }); this._added++; this._inputs.push(input); return this; }; module.exports = FileMuxer; × Search results Close "},"lib_keypair.js.html":{"id":"lib_keypair.js.html","title":"Source: lib/keypair.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/keypair.js 'use strict'; var bitcore = require('bitcore-lib'); var crypto = require('crypto'); var merge = require('merge'); var Message = require('bitcore-message'); var curve = bitcore.deps.elliptic.curves.secp256k1; var ecdsa = new bitcore.deps.elliptic.ec(curve); /** * Represents a ECDSA key pair * @constructor * @param {String|Buffer} privkey - WIF encoded ECDSA private key */ function KeyPair(privkey) { if (!(this instanceof KeyPair)) { return new KeyPair(privkey); } if (privkey) { this._privkey = bitcore.PrivateKey.fromString(privkey); } else { this._privkey = bitcore.PrivateKey.fromRandom(); } this._pubkey = this._privkey.toPublicKey(); } /** * Returns the private key * @returns {String} key */ KeyPair.prototype.getPrivateKey = function() { return this._privkey.toString(); }; /** * Returns the public key * @returns {String} key */ KeyPair.prototype.getPublicKey = function() { return this._pubkey.toString(); }; /** * Returns the NodeID derived from the public key * @returns {String} nodeID - RIPEMD160 hash of public key */ KeyPair.prototype.getNodeID = function() { return bitcore.crypto.Hash.sha256ripemd160( this._pubkey.toBuffer() ).toString('hex'); }; /** * Returns the bitcoin address version of the nodeID * @returns {String} address - Base58 encoded address */ KeyPair.prototype.getAddress = function() { return bitcore.Address.fromPublicKeyHash( new Buffer(this.getNodeID(), 'hex') ).toString(); }; /** * Signs the supplied message with the private key * @param {String|Buffer} message - The message to sign * @param {Object} options * @param {Boolean} options.compact - Compact signature format (default: true) * @returns {String} signature */ KeyPair.prototype.sign = function(message, options) { var sign = null; var opts = merge({ compact: true }, options); if (opts.compact) { sign = Message(message).sign(this._privkey); } else { if (!Buffer.isBuffer(message)) { message = new Buffer(message, 'utf8'); } sign = ecdsa.sign( crypto.createHash('sha256').update(message).digest('hex'), this.getPrivateKey() ).toDER('hex'); } return sign; }; module.exports = KeyPair; × Search results Close "},"lib_keyring.js.html":{"id":"lib_keyring.js.html","title":"Source: lib/keyring.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/keyring.js 'use strict'; var assert = require('assert'); var fs = require('fs'); var DataCipherKeyIv = require('./cipherkeyiv'); var crypto = require('crypto'); /** * A {@link DataCipherKeyIv} factory with file system persistence * @constructor * @param {String} filePath - Path to store keyring file * @param {String} passPhrase - Passphrase to encrypt/decrypt keyring */ function KeyRing(filePath, passPhrase) { if (!(this instanceof KeyRing)) { return new KeyRing(filePath, passPhrase); } assert(typeof filePath === 'string', 'Invalid path supplied to keyring'); this._path = filePath; this._pass = passPhrase || ''; this._keys = this._loadKeyRingFromDisk(); } KeyRing.DEFAULTS = { algorithm: 'aes-256-ctr' }; /** * Returns the stored {@link KeyPair} for the given id * @param {String} id - Arbitrary key ID to load * @returns {KeyPair|null} */ KeyRing.prototype.get = function(id) { if (!this._keys[id]) { return null; } return DataCipherKeyIv.fromObject(this._keys[id]); }; /** * Returns the stored {@link KeyPair} for the given id * @param {String} id - Arbitrary key ID to load * @param {KeyPair} keypair - KeyPair instance to set */ KeyRing.prototype.set = function(id, cipherKeyIv) { this._keys[id] = cipherKeyIv.toObject(); this._saveKeyRingToDisk(); return cipherKeyIv; }; /** * Returns the stored {@link KeyPair} for the given id * @param {String} id - Generate a key for use with the given ID * @returns {KeyPair} */ KeyRing.prototype.generate = function(id) { return this.set(id, DataCipherKeyIv()); }; /** * Loads or creates the keyring file * @private */ KeyRing.prototype._loadKeyRingFromDisk = function() { if (!fs.existsSync(this._path)) { fs.writeFileSync(this._path, this._encrypt(JSON.stringify({}))); } return JSON.parse(this._decrypt(fs.readFileSync(this._path).toString())); }; /** * Saves the keyring file to disk * @private */ KeyRing.prototype._saveKeyRingToDisk = function() { return fs.writeFileSync( this._path, this._encrypt(JSON.stringify(this._keys)) ); }; /** * Encrypts the data with the passphrase * @private * @param {String} data - Data to encrypt */ KeyRing.prototype._encrypt = function(data) { var cipher = crypto.createCipher(KeyRing.DEFAULTS.algorithm, this._pass); var enc = cipher.update(data, 'utf8', 'hex'); enc += cipher.final('hex'); return enc; }; /** * Decrypts the data with the passphrase * @private * @param {String|Buffer} data - Data to encrypt */ KeyRing.prototype._decrypt = function(data) { var decipher = crypto.createDecipher(KeyRing.DEFAULTS.algorithm, this._pass); var dec = decipher.update(data, 'hex', 'utf8'); dec += decipher.final('utf8'); return dec; }; module.exports = KeyRing; × Search results Close "},"lib_storage_adapters_level_filestore.js.html":{"id":"lib_storage_adapters_level_filestore.js.html","title":"Source: lib/storage/adapters/level/filestore.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/adapters/level/filestore.js 'use strict'; var stream = require('readable-stream'); /** * Exposes an file read/write stream interface in/out of levelup * @constructor * @param {Object} db - Levelup database instance */ function LevelDBFileStore(db) { if (!(this instanceof LevelDBFileStore)) { return new LevelDBFileStore(db); } this._db = db; } /** * Determines if the file is already stored in the db * @param {String} key - The key for the file stored * @param {Function} callback - Called with boolean indicating existence */ LevelDBFileStore.prototype.exists = function(key, callback) { this._db.get(key + ' 0', function(err) { callback(!err); }); }; /** * Deletes the file pieces from the database * @param {String} key - The key for the file stored * @param {Function} callback - Called with boolean indicating existence */ LevelDBFileStore.prototype.reset = function(key, callback) { var self = this; var index = 0; function _del(index, callback) { var itemkey = key + ' ' + index.toString(); self._db.get(itemkey, function(err) { index++; if (!err) { self._db.del(itemkey); _del(index, callback); } else { callback(); } }); } _del(index, callback); }; /** * Returns a readable stream of the file at the given key * @param {String} key - The key for the file to read * @returns {ReadableStream} */ LevelDBFileStore.prototype.createReadStream = function(key) { var self = this; var index = 0; return new stream.Readable({ read: function() { var rs = this; self._db.get(key + ' ' + index.toString(), { valueEncoding: 'binary' }, function(err, result) { if (err) { if (err.type === 'NotFoundError') { return rs.push(null); } else { return rs.emit('error', err); } } index++; rs.push(Buffer(result, 'binary')); }); } }); }; /** * Returns a writable stream for a file at the given key * @param {String} key - The key for the file to read * @returns {WritableStream} */ LevelDBFileStore.prototype.createWriteStream = function(key) { var self = this; var index = 0; return new stream.Writable({ write: function(bytes, encoding, callback) { var ws = this; self._db.put(key + ' ' + index.toString(), bytes, { valueEncoding: 'binary' }, function(err) { if (err) { return ws.emit('error', err); } index++; callback(); }); } }); }; module.exports = LevelDBFileStore; × Search results Close "},"lib_storage_adapters_level_index.js.html":{"id":"lib_storage_adapters_level_index.js.html","title":"Source: lib/storage/adapters/level/index.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/adapters/level/index.js 'use strict'; var inherits = require('util').inherits; var StorageAdapter = require('../../adapter'); var StorageItem = require('../../item'); var levelup = require('levelup'); var LevelDBFileStore = require('./filestore'); var merge = require('merge'); var fs = require('fs'); var path = require('path'); /** * Implements an LevelDB storage adapter interface * @extends {StorageAdapter} * @param {String} path - Path to store the level db * @param {Function} backend - Optional backend override for levelup * @constructor */ function LevelDBStorageAdapter(path, backend) { if (!(this instanceof LevelDBStorageAdapter)) { return new LevelDBStorageAdapter(path, backend); } this._db = levelup(path, { db: backend }); this._fs = new LevelDBFileStore(this._db); this._isUsingDefaultBackend = !backend; this._path = path; } inherits(LevelDBStorageAdapter, StorageAdapter); /** * Implements the abstract {@link StorageAdapter#_get} * @private * @param {String} key * @param {Function} callback */ LevelDBStorageAdapter.prototype._get = function(key, callback) { var self = this; this._db.get(key + '.info', { fillCache: false }, function(err, value) { if (err) { return callback(err); } var result = new StorageItem(JSON.parse(value)); self._fs.exists(key + '.data', function(exists) { if (exists) { result.shard = self._fs.createReadStream(key + '.data'); } else { result.shard = self._fs.createWriteStream(key + '.data'); } callback(null, result); }); }); }; /** * Implements the abstract {@link StorageAdapter#_peek} * @private * @param {String} key * @param {Function} callback */ LevelDBStorageAdapter.prototype._peek = function(key, callback) { this._db.get(key + '.info', { fillCache: false }, function(err, value) { if (err) { return callback(err); } callback(null, new StorageItem(JSON.parse(value))); }); }; /** * Implements the abstract {@link StorageAdapter#_put} * @private * @param {String} key * @param {StorageItem} item * @param {Function} callback */ LevelDBStorageAdapter.prototype._put = function(key, item, callback) { var self = this; item.shard = null; // NB: Don't store any shard data here this._db.get(key + '.info', { fillCache: false }, function(err, existing) { if (err) { existing = JSON.stringify({}); } var plain = JSON.parse(JSON.stringify(item)); var value = merge.recursive(JSON.parse(existing), plain); self._db.put(key + '.info', JSON.stringify(value), { sync: true }, function(err) { if (err) { return callback(err); } callback(null); }); }); }; /** * Implements the abstract {@link StorageAdapter#_del} * @private * @param {String} key * @param {Function} callback */ LevelDBStorageAdapter.prototype._del = function(key, callback) { var self = this; this._db.del(key + '.info', function(err) { if (err) { return callback(err); } self._fs.reset(key + '.data', function(err) { if (err) { return callback(err); } callback(null); }); }); }; /** * Implements the abstract {@link StorageAdapter#_size} * @private * @param {Function} callback */ LevelDBStorageAdapter.prototype._size = function(callback) { var self = this; var size = 0; if (!this._isUsingDefaultBackend) { // NB: We can't calculate for every possible backend, so return 0 and // NB: let implementors extend this class to provide the real value. return callback(null, size); } // NB: This operation is actually synchronous, but given that LevelDB compacts // NB: files into levels, the cost of executing `stat` on just a handful of // NB: files should be negligble. try { size = fs.readdirSync(this._path).map(function(filePath) { return fs.statSync(path.join(self._path, filePath)); }).reduce(function(statsA, statsB) { return { size: statsA.size + statsB.size }; }, { size: 0 }).size; } catch (err) { return callback(err); } callback(null, size); }; /** * Implements the abstract {@link StorageAdapter#_keys} * @private * @param {Function} callback */ LevelDBStorageAdapter.prototype._keys = function(callback) { var keys = []; var stream = this._db.createKeyStream(); stream.on('data', function(key) { var parts = key.split('.'); var name = parts[0]; var ext = parts[1]; if (ext === 'info') { keys.push(name); } }); stream.on('end', function() { callback(null, keys); }); stream.on('error', callback); }; module.exports = LevelDBStorageAdapter; × Search results Close "},"lib_storage_adapter.js.html":{"id":"lib_storage_adapter.js.html","title":"Source: lib/storage/adapter.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/adapter.js 'use strict'; var stream = require('readable-stream'); var assert = require('assert'); var Item = require('./item'); var Contract = require('../contract'); /** * Abstract base class for storage adapter * @constructor */ function StorageAdapter() { if (!(this instanceof StorageAdapter)) { return new StorageAdapter(); } } /** * Calls the implemented {@link StorageAdapter#_get} and validates the result * @param {String} key - Shard hash to get metadata for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageAdapter.prototype.get = function(key, callback) { assert(typeof key === 'string', 'Invalid key supplied'); assert(key.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); return this._get(key, callback); }; /** * Calls the implemented {@link StorageAdapter#_peek} and validates the result * @param {String} key - Shard hash to get metadata for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageAdapter.prototype.peek = function(key, callback) { assert(typeof key === 'string', 'Invalid key supplied'); assert(key.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); return this._peek(key, callback); }; /** * Calls the implemented {@link StorageAdapter#_put} and validates the input * @param {StorageItem} item - Item to write to storage * @param {Function} callback - Called on complete write */ StorageAdapter.prototype.put = function(item, callback) { assert(item instanceof Item, 'Invalid storage item supplied'); assert(typeof callback === 'function', 'Callback function must be supplied'); for (var nodeID in item.contracts) { if (item.contracts[nodeID] instanceof Contract) { item.contracts[nodeID] = item.contracts[nodeID].toObject(); } } item.updateTimestamp(); return this._put(item.hash, item, callback); }; /** * Calls the implemented {@link StorageAdapter#_del} * @param {String} key - Shard hash to delete the data for * @param {Function} callback - Called with error or {@link StorageItem} */ StorageAdapter.prototype.del = function(key, callback) { assert(typeof key === 'string', 'Invalid key supplied'); assert(key.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); return this._del(key, callback); }; /** * Calls the implemented {@link StorageAdapter#_size} * @param {Function} callback - Called with error or number of bytes stored */ StorageAdapter.prototype.size = function(callback) { assert(typeof callback === 'function', 'Callback function must be supplied'); return this._size(callback); }; /** * Calls the implemented {@link StorageAdapter#_keys} and returns a readable * stream containing each stored item * @return {ReadableStream} */ StorageAdapter.prototype.createReadStream = function() { var self = this; var keys = null; var current = 0; return new stream.Readable({ objectMode: true, read: function() { var rstream = this; function handleError(err) { rstream.emit('error', err); rstream.push(null); } if (!keys) { return self._keys(function(err, result) { if (err) { return handleError(err); } keys = result; if (!keys[current]) { return rstream.push(null); } self.peek(keys[current], function(err, item) { if (err) { return handleError(err); } current++; rstream.push(item); }); }); } if (!keys[current]) { return rstream.push(null); } self.peek(keys[current], function(err, item) { if (err) { return handleError(err); } current++; rstream.push(item); }); } }); }; /** * Performs lookup and provides an {@link StorageItem} to the callback * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._get = function(/* key, callback */) { throw new Error('Method not implemented'); }; /** * Performs lookup and provides an {@link StorageItem} to the callback but does * not initialize any shard read/write stream * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._peek = function(/* key, callback */) { throw new Error('Method not implemented'); }; /** * Delete the shard data at the given key * @abstract * @param {String} key - Shard hash * @param {Function} callback - Called on complete */ StorageAdapter.prototype._del = function(/* key, callback */) { throw new Error('Method not implemented'); }; /** * Stores the {@link StorageItem} * @abstract * @param {String} key - Shard hash * @param {Item} item - Item to store * @param {Function} callback - Called on complete */ StorageAdapter.prototype._put = function(/* item, callback */) { throw new Error('Method not implemented'); }; /** * Returns the hashes of all shards stored * @abstract * @param {Function} callback - Called on complete */ StorageAdapter.prototype._keys = function(/* callback */) { throw new Error('Method not implemented'); }; /** * Returns the number of bytes stored * @abstract * @param {Function} callback - Called on complete */ StorageAdapter.prototype._size = function(/* callback */) { throw new Error('Method not implemented'); }; module.exports = StorageAdapter; × Search results Close "},"lib_manager.js.html":{"id":"lib_manager.js.html","title":"Source: lib/manager.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/manager.js 'use strict'; var constants = require('./constants'); var assert = require('assert'); var StorageAdapter = require('./storage/adapter'); var StorageItem = require('./storage/item'); var merge = require('merge'); var EventEmitter = require('events').EventEmitter; var inherits = require('util').inherits; /** * Interface for managing contracts, shards, and audits * @constructor * @extends {EventEmitter} * @param {StorageAdapter} storage - Storage adapter to use * @param {Object} options * @param {Boolean} options.disableReaper - Don't perform periodic reaping of * stale contracts * @param {Number} options.maxCapacity - Max number of bytes to allow in storage */ function Manager(storage, options) { if (!(this instanceof Manager)) { return new Manager(storage, options); } assert(storage instanceof StorageAdapter, 'Invalid storage adapter'); this._options = merge(Object.create(Manager.DEFAULTS), options); this._storage = storage; this._capacityReached = false; this._initShardReaper(); } inherits(Manager, EventEmitter); /** * Triggered when the underlying storage adapter reaches capacity * @event Manager#locked */ /** * Triggered when the underlying storage adapter has newly freed space * @event Manager#unlocked */ Manager.DEFAULTS = { disableReaper: false, maxCapacity: Infinity }; /** * Loads the storage {@link Item} at the given key * @param {String} hash - Shard hash to load data for * @param {Function} callback - Called with error or {@link StorageItem} */ Manager.prototype.load = function(hash, callback) { assert(typeof hash === 'string', 'Invalid key supplied'); assert(hash.length === 40, 'Key must be 160 bit hex string'); assert(typeof callback === 'function', 'Callback function must be supplied'); this._storage.get(hash, function(err, item) { if (err) { return callback(err); } if (!(item instanceof StorageItem)) { return callback(new Error('Storage adapter provided invalid result')); } callback(null, item); }); }; /** * Saves the storage {@link StorageItem} at the given key * @param {StorageItem} item - The {@link StorageItem} to store * @param {Function} callback - Called on complete */ Manager.prototype.save = function(item, callback) { var self = this; assert(item instanceof StorageItem, 'Invalid storage item supplied'); assert(typeof callback === 'function', 'Callback function must be supplied'); if (this._capacityReached) { return callback(new Error('Storage capacity reached')); } this._storage.put(item, function(err) { if (err) { return callback(err); } self._checkCapacity(); callback(null); }); }; /** * Enumerates all storage contracts and reaps stale data * @param {Function} callback - Called on complete */ Manager.prototype.clean = function(callback) { var self = this; var rstream = this._storage.createReadStream(); rstream.on('data', function(item) { rstream.pause(); var total = Object.keys(item.contracts).length; var endedOrIncomplete = 0; for (var nodeID in item.contracts) { var ended = item.contracts[nodeID].get('store_end') &lt; Date.now(); var incomplete = !item.contracts[nodeID].isComplete(); if (ended || incomplete) { endedOrIncomplete++; } } if (total === endedOrIncomplete) { self._storage.del(item.hash, function(/* err */) { rstream.resume(); }); } else { rstream.resume(); } }); rstream.on('end', function() { self._checkCapacity(); callback(); }); }; /** * Checks the underlying storage adapter's size and determines if our defined * capacity has been reached * @private */ Manager.prototype._checkCapacity = function() { var self = this; this._storage.size(function(err, bytes) { if (err) { return self.emit('error', err); } var capacityReached = bytes &gt;= self._options.maxCapacity; if (capacityReached !== self._capacityReached) { self.emit(capacityReached ? 'locked' : 'unlocked'); } self._capacityReached = capacityReached; }); }; /** * Initialize the shard reaper to check for stale contracts and reap shards * @private */ Manager.prototype._initShardReaper = function() { var self = this; if (!this._options.disableReaper) { this.clean(function() { setTimeout(self._initShardReaper.bind(self), constants.CLEAN_INTERVAL); }); } }; module.exports = Manager; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: index.js /** * @module storj */ 'use strict'; require('./lib/patches')(); // NB: Apply any monkey patches module.exports.version = require('./lib/version'); /** {@link Network} */ module.exports.Network = require('./lib/network'); /** {@link Transport} */ module.exports.Transport = require('./lib/network/transport'); /** {@link Contact} */ module.exports.Contact = require('./lib/network/contact'); /** {@link RateLimiter} */ module.exports.RateLimiter = require('./lib/network/ratelimiter'); /** {@link DataChannelClient} */ module.exports.DataChannelClient = require('./lib/datachannel/client'); /** {@link DataChannelServer} */ module.exports.DataChannelServer = require('./lib/datachannel/server'); /** {@link Protocol} */ module.exports.Protocol = require('./lib/network/protocol'); /** {@link TunnelServer} */ module.exports.Tunnel = require('./lib/tunnel/server'); /** {@link TunnelMuxer} */ module.exports.TunnelMuxer = require('./lib/tunnel/multiplexer'); /** {@link TunnelDemuxer} */ module.exports.TunnelDemuxer = require('./lib/tunnel/demultiplexer'); /** {@link TunnelClient} */ module.exports.TunnelClient = require('./lib/tunnel/client'); /** {@link EncryptStream} */ module.exports.EncryptStream = require('./lib/cryptostream/encrypt'); /** {@link DecryptStream} */ module.exports.DecryptStream = require('./lib/cryptostream/decrypt'); /** {@link FileMuxer} */ module.exports.FileMuxer = require('./lib/filemuxer'); /** {@link FileDemuxer} */ module.exports.FileDemuxer = require('./lib/filedemuxer'); /** {@link Padder} */ module.exports.Padder = require('./lib/padder'); /** {@link Unpadder} */ module.exports.Unpadder = require('./lib/unpadder'); /** {@link Contract} */ module.exports.Contract = require('./lib/contract'); /** {@link AuditStream} */ module.exports.AuditStream = require('./lib/auditstream'); /** {@link ProofStream} */ module.exports.ProofStream = require('./lib/proofstream'); /** {@link Verification} */ module.exports.Verification = require('./lib/verification'); /** {@link Manager} */ module.exports.Manager = require('./lib/manager'); /** {@link StorageAdapter} */ module.exports.StorageAdapter = require('./lib/storage/adapter'); /** {@link StorageMigration} */ module.exports.StorageMigration = require('./lib/storage/migration'); /** {@link LevelDBStorageAdapter} */ module.exports.LevelDBStorageAdapter = require('./lib/storage/adapters/level'); /** {@link RAMStorageAdapter} */ module.exports.RAMStorageAdapter = require('./lib/storage/adapters/ram'); /** {@link StorageItem} */ module.exports.StorageItem = require('./lib/storage/item'); /** {@link DataCipherKeyIv} */ module.exports.DataCipherKeyIv = require('./lib/cipherkeyiv'); /** {@link KeyPair} */ module.exports.KeyPair = require('./lib/keypair'); /** {@link KeyRing} */ module.exports.KeyRing = require('./lib/keyring'); /** {@link RenterInterface} */ module.exports.RenterInterface = require('./lib/interfaces/renter'); /** {@link FarmerInterface} */ module.exports.FarmerInterface = require('./lib/interfaces/farmer'); /** {@link TunnelerInterface} */ module.exports.TunnelerInterface = require('./lib/interfaces/tunneler'); /** {@link BridgeClient} */ module.exports.BridgeClient = require('./lib/bridgeclient'); /** {@link constants} */ module.exports.constants = require('./lib/constants'); /** {@link utils} */ module.exports.utils = require('./lib/utils'); × Search results Close "},"lib_constants.js.html":{"id":"lib_constants.js.html","title":"Source: lib/constants.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/constants.js /** * @module storj/constants */ 'use strict'; module.exports = { /** @constant {String} CIPHER_ALG - Cipher/Decipher algorithm */ CIPHER_ALG: 'aes-256-ctr', /** @constant {Number} PREFIX - NodeID prefix (same as bitcoin) */ PREFIX: 0x00, /** @constant {Number} NONCE_EXPIRE - Time to honor a signed message */ NONCE_EXPIRE: 10000, /** @constant {Number} AUDIT_BYTES - Number of bytes for audit challenge */ AUDIT_BYTES: 32, /** @constant {Number} CLEAN_INTERVAL - Interval for reaping stale shards */ CLEAN_INTERVAL: 10800000, /** @constant {Number} TUNNEL_ANNOUNCE_INTERVAL - Announce tunnel state */ TUNNEL_ANNOUNCE_INTERVAL: 900000, /** @constant {Number} OPCODE_TUNRPC_PREFIX - Opcode for tunnel rpc message */ OPCODE_TUNRPC_PREFIX: 0x0c, /** @constant {Number} OPCODE_TUNDCX_PREFIX - Opcode for tunnel datachannel */ OPCODE_TUNDCX_PREFIX: 0x0d, /** @constant {Number} OPCODE_TUNNELER_PREFIX - Prefix opcode for tunneler */ OPCODE_TUNNELER_PREFIX: 0x0e, /** @constant {Number} OPCODE_CONTRACT_PREFIX - Prefix opcode for contracts */ OPCODE_CONTRACT_PREFIX: 0x0f, /** @constant {Number} OPCODE_DEG_NULL - Opcode for null criteria degree */ OPCODE_DEG_NULL: 0x00, /** @constant {Number} OPCODE_DEG_LOW - Opcode for low criteria degree */ OPCODE_DEG_LOW: 0x01, /** @constant {Number} OPCODE_DEG_MED - Opcode for medium criteria degree */ OPCODE_DEG_MED: 0x02, /** @constant {Number} OPCODE_DEG_HIGH - Opcode for medium criteria degree */ OPCODE_DEG_HIGH: 0x03, /** @constant {Number} MAX_CONCURRENT_OFFERS - Number of concurrent offers */ MAX_CONCURRENT_OFFERS: 6, /** @constant {Number} MAX_CONCURRENT_AUDITS - Number of concurrent audits */ MAX_CONCURRENT_AUDITS: 3, /** @constant MAX_FIND_TUNNEL_RELAYS - Max times to relay FIND_TUNNEL */ MAX_FIND_TUNNEL_RELAYS: 2, /** @constant {Number} SUBSCRIBE_THROTTLE - Wait between opcode subscribe */ SUBSCRIBE_THROTTLE: 3000 }; × Search results Close "},"lib_utils.js.html":{"id":"lib_utils.js.html","title":"Source: lib/utils.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/utils.js /** * @module storj/utils */ 'use strict'; var KeyPair = require('./keypair'); var crypto = require('crypto'); var semver = require('semver'); var ip = require('ip'); var bitcore = require('bitcore-lib'); var ECIES = require('bitcore-ecies'); /** * Returns the SHA-256 hash of the input * @param {String|Buffer} input - Data to hash * @returns {String} */ module.exports.sha256 = function(input) { return crypto.createHash('sha256').update(input).digest('hex'); }; /** * Returns the RIPEMD-160 hash of the input * @param {String|Buffer} input - Data to hash * @returns {String} */ module.exports.rmd160 = function(input) { return crypto.createHash('rmd160').update(input).digest('hex'); }; /** * Returns the RIPEMD-160 SHA-256 hash of this input * @param {String|Buffer} input - Data to hash * @returns {String} */ module.exports.rmd160sha256 = function(input) { return module.exports.rmd160(module.exports.sha256(input)); }; /** * Returns the next power of two number * @param {Number} number * @returns {Number} */ module.exports.getNextPowerOfTwo = function(num) { return Math.pow(2, Math.ceil(Math.log(num) / Math.log(2))); }; /** * Generates a unique token * @returns {String} */ module.exports.generateToken = function() { return module.exports.rmd160sha256(crypto.randomBytes(512)); }; /** * Returns a stringified URL from the supplied contact object * @param {Object} contact * @param {String} contact.address * @param {Number} contact.port * @param {String} contact.nodeID * @returns {String} */ module.exports.getContactURL = function(contact) { return [ 'storj://', contact.address, ':', contact.port, '/', contact.nodeID ].join(''); }; /** * Returns whether or not the supplied semver tag is compatible * @param {String} version - The semver tag from the contact * @returns {Boolean} compatible */ module.exports.isCompatibleVersion = function(version) { var local = require('./version').protocol; var remote = version; var sameMajor = semver.major(local) === semver.major(remote); var sameMinor = semver.minor(local) === semver.minor(remote); var diffs = ['prerelease', 'prepatch', 'preminor', 'premajor']; if (diffs.indexOf(semver.diff(remote, local)) !== -1) { return false; } else if (semver.major(local) === 0 &amp;&amp; sameMajor) { return sameMinor; } else { return sameMajor; } }; /** * Determines if the supplied contact is valid * @param {Contact} contact - The contact information for a given peer * @param {Boolean} loopback - Allows contacts that are localhost * @returns {Boolean} */ module.exports.isValidContact = function(contact, loopback) { if (!contact) { return false; } var isValidAddr = ip.isV4Format(contact.address) || ip.isV6Format(contact.address) || ip.isPublic(contact.address); var isValidPort = contact.port &gt; 0; var isAllowedAddr = ip.isLoopback(contact.address) ? !!loopback : true; return isValidPort &amp;&amp; isValidAddr &amp;&amp; isAllowedAddr; }; /** * Creates an ECIES ciper object from a private and a public key * @param {String} privateKey - The private key of the sender * @param {String} publicKey - The public key of the recipient * @returns {Object} */ module.exports.createEciesCipher = function(privateKey, publicKey) { var cipher = ECIES(); cipher.privateKey(KeyPair(privateKey)._privkey); cipher.publicKey(bitcore.PublicKey.fromDER(Buffer(publicKey, 'hex'))); return cipher; }; /** * Returns number of bytes from human readable size and unit strings * @param {String|Number} size - The size measurement * @param {String} unit - The unit of measure (MB|GB|TB) * @returns {Number} */ module.exports.toNumberBytes = function(size, unit) { switch (unit.toUpperCase()) { case 'MB': size = Number(size) * Math.pow(1024, 2); break; case 'GB': size = Number(size) * Math.pow(1024, 3); break; case 'TB': size = Number(size) * Math.pow(1024, 4); break; default: throw new Error('Unit must be one of TB, GB, or MB'); } return Number(size.toFixed()); }; × Search results Close "},"lib_padder.js.html":{"id":"lib_padder.js.html","title":"Source: lib/padder.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/padder.js 'use strict'; var stream = require('readable-stream'); var inherits = require('util').inherits; /** * Takes an input stream and pads the tail with zeroes to the next byte mulitple * @constructor */ function Padder() { if (!(this instanceof Padder)) { return new Padder(); } this._bytesRead = 0; stream.Transform.call(this); } inherits(Padder, stream.Transform); Padder.DEFAULTS = { multiple: 1024 * 1024 * 8 }; /** * Implements a simple passthrough while tracking number of bytes * @private */ Padder.prototype._transform = function(chunk, enc, callback) { this._bytesRead += chunk.length; this.push(chunk); callback(null); }; /** * Pads the tail of the stream with zeroes * @private */ Padder.prototype._flush = function(callback) { var remainder = this._bytesRead % Padder.DEFAULTS.multiple; if (this._bytesRead &lt; Padder.DEFAULTS.multiple) { this.push(Buffer(Padder.DEFAULTS.multiple - this._bytesRead).fill(0)); return callback(null); } if (remainder) { this.push(Buffer(Padder.DEFAULTS.multiple - remainder).fill(0)); return callback(null); } callback(null); }; module.exports = Padder; × Search results Close "},"lib_proofstream.js.html":{"id":"lib_proofstream.js.html","title":"Source: lib/proofstream.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/proofstream.js 'use strict'; var assert = require('assert'); var MerkleTree = require('mtree'); var utils = require('./utils'); var inherits = require('util').inherits; var stream = require('readable-stream'); var crypto = require('crypto'); /** * Provides interface for proving possession of a file for an * {@link AuditStream} * @constructor * @param {Array} leaves - Bottom leaves of the audit merkle tree * @param {String} challenge - The challenge data in hex to prepend to shard */ function ProofStream(leaves, challenge) { if (!(this instanceof ProofStream)) { return new ProofStream(leaves, challenge); } assert(Array.isArray(leaves), 'Merkle leaves must be an array'); assert.ok(challenge, 'Invalid challenge supplied'); this._tree = new MerkleTree(this._generateLeaves(leaves), utils.rmd160sha256); this._challenge = challenge; this._hasher = crypto.createHash('sha256').update(this._challenge); this._proof = null; stream.Transform.call(this, { objectMode: true }); } inherits(ProofStream, stream.Transform); /** * Returns the generated proof structure * @return {Array} */ ProofStream.prototype.getProofResult = function() { assert(Array.isArray(this._proof), 'Proof generation is not complete'); return this._proof; }; /** * Handles writing the shard data to the proof stream * @private */ ProofStream.prototype._transform = function(chunk, encoding, next) { this._hasher.update(chunk.toString('hex')); next(); }; ProofStream.prototype._flush = function(done) { try { this._generateProof(); } catch(err) { return done(err); } this.push(this.getProofResult()); done(); }; /** * Calculate audit response * @private * @param {String} challenge - Challenge string sent by auditor * @returns {Array} result - Challenge response */ ProofStream.prototype._generateProof = function() { var response = utils.rmd160(this._hasher.digest('hex')); var leaves = this._tree.level(this._tree.levels() - 1); var challengenum = leaves.indexOf(utils.rmd160sha256(response)); assert(challengenum !== -1, 'Failed to generate proof'); var branches = [response]; for (var i = (this._tree.levels() - 1); i &gt; 0; i--) { var level = this._tree.level(i); if (challengenum % 2 === 0) { branches = [branches, level[challengenum + 1]]; } else { branches = [level[challengenum - 1], branches]; } challengenum = Math.floor(challengenum / 2); } this._proof = branches; }; /** * Generates the bottom leaves of the tree to the next power of two * @private * @param {Array} leaves */ ProofStream.prototype._generateLeaves = function(leaves) { var numEmpty = utils.getNextPowerOfTwo(leaves.length) - leaves.length; var emptyLeaves = []; for (var i = 0; i &lt; numEmpty; i++) { emptyLeaves.push(utils.rmd160sha256('')); } return leaves.concat(emptyLeaves); }; module.exports = ProofStream; × Search results Close "},"lib_network_protocol.js.html":{"id":"lib_network_protocol.js.html","title":"Source: lib/network/protocol.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/protocol.js 'use strict'; var assert = require('assert'); var utils = require('../utils'); var ProofStream = require('../proofstream'); var Contract = require('../contract'); var StorageItem = require('../storage/item'); var stream = require('readable-stream'); var kad = require('kad'); var async = require('async'); var Contact = require('./contact'); var constants = require('../constants'); /** * Defines the Storj protocol methods and mounts on a {@link Network} instance * to handle Storj protocol messages * @constructor * @param {Object} options * @param {Network} options.network - Network instance to bind to */ function Protocol(opts) { if (!(this instanceof Protocol)) { return new Protocol(opts); } assert(typeof opts === 'object' , 'Invalid options supplied'); this._network = opts.network; this._logger = this._network._logger; } /** * Handles OFFER messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleOffer = function(params, callback) { var self = this; var contract; this._logger.info( 'handling storage contract offer from %s', params.contact.nodeID ); try { contract = Contract.fromObject(params.contract); } catch (err) { return callback(new Error('Invalid contract format')); } // TODO: Ultimately we will need to create a robust decision engine that will // TODO: allow us to better determine if the received offer is in our best // TODO: interest. For now, we just make sure that we have the data_shard // TODO: from the OFFER and we wish to CONSIGN it. // For now, we just accept any storage offer we get that matches our own... var key = contract.get('data_hash'); this._verifyContract(contract, params.contact, function(err) { if (err) { return callback(err); } var doConsign = self._network._pendingContracts[key].bind( self._network, Contact(params.contact), contract ); delete self._network._pendingContracts[key]; var item = new StorageItem({ hash: key }); item.contracts[params.contact.nodeID] = contract; self._network._manager.save(item, function(err) { if (err) { return callback(err); } self._logger.info( 'accepting storage contract offer from %s', params.contact.nodeID ); callback(null, { contract: contract.toObject() }); doConsign(); }); }); }; /** * Verifies that the contract is valid * @private */ Protocol.prototype._verifyContract = function(contract, contact, callback) { if (!this._network._pendingContracts[contract.get('data_hash')]) { return callback(new Error('Contract no longer open to offers')); } if (!contract.verify('farmer', contact.nodeID)) { return callback(new Error('Invalid signature from farmer')); } contract.sign('renter', this._network._keypair.getPrivateKey()); if (!contract.isComplete()) { return callback(new Error('Contract is not complete')); } callback(null); }; /** * Handles AUDIT messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleAudit = function(params, callback) { var self = this; var limit = constants.MAX_CONCURRENT_AUDITS; if (!Array.isArray(params.audits)) { return callback(new Error('Invalid audit list supplied')); } this._logger.info( 'handling storage audit from %s', params.contact.nodeID ); async.mapLimit(params.audits, limit, function(audit, done) { self._proveShardExistence( audit.data_hash, audit.challenge, params.contact.nodeID, done ); }, function onComplete(err, proofs) { if (err) { return callback(err); } callback(null, { proofs: proofs }); }); }; /** * Performs a single audit proof generation * @private * @param {String} hash - The hash of the shard to prove * @param {String} challenge - The challenge input for proof generation * @param {String} nodeID - The nodeID of the auditor * @param {Function} callback - Called on completion of the proof generation */ Protocol.prototype._proveShardExistence = function(hash, chall, nid, cb) { if (!hash || !chall) { return cb(new Error('Invalid data hash or challenge provided')); } this._network._manager.load(hash, function(err, item) { if (err) { return cb(err); } if (item.shard instanceof stream.Writable) { return cb(new Error('Shard not found')); } var proof = new ProofStream(item.trees[nid], chall); item.shard.pipe(proof).on('finish', function() { cb(null, proof.getProofResult()); }); }); }; /** * Handles CONSIGN messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleConsign = function(params, callback) { var self = this; var token = utils.generateToken(); this._logger.info( 'handling storage consignment request from %s', params.contact.nodeID ); self._network._manager.load(params.data_hash, function(err, item) { if (err) { return callback(err); } var contract = item.contracts[params.contact.nodeID]; var t = Date.now(); item.trees[contract.get('renter_id')] = params.audit_tree; try { assert( t &lt; contract.get('store_end') &amp;&amp; t &gt; contract.get('store_begin'), 'Consignment violates contract store time' ); } catch (err) { return callback(err); } self._network._manager.save(item, function(err) { if (err) { return callback(err); } self._logger.info( 'authorizing data channel for %s', params.contact.nodeID ); self._network._channel.accept(token, params.data_hash); callback(null, { token: token }); }); }); }; /** * Handles RETRIEVE messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleRetrieve = function(params, callback) { var self = this; var hash = params.data_hash; var token = utils.generateToken(); // TODO: We will need to increment the download count to track payments, as // TODO: well as make sure that the requester is allowed to fetch the shard // TODO: as part of the contract. self._network._manager.load(hash, function(err, item) { if (err) { return callback(err); } self._logger.info( 'authorizing data channel for %s', params.contact.nodeID ); self._network._channel.accept(token, item.hash); callback(null, { token: token }); }); }; /** * Handles PROBE messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleProbe = function(params, callback) { var message = new kad.Message({ method: 'PING', params: { contact: this._network._contact } }); this._logger.info('performing probe for %s', params.contact.nodeID); this._network._transport.send(params.contact, message, function(err) { if (err) { return callback(new Error('Probe failed, you are not addressable')); } callback(null, {}); }); }; /** * Handles FIND_TUNNEL messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleFindTunnel = function(params, callback) { var available = this._network._transport._tunserver.hasTunnelAvailable(); var knownTunnelers = this._network._tunnelers.getContactList(); var tunnels = available ? [this._network._contact].concat(knownTunnelers) : knownTunnelers; this._logger.info('finding tunnels for %s', params.contact.nodeID); if (tunnels.length) { this._logger.info( 'sending %s tunnels to %s', tunnels.length, params.contact.nodeID ); return callback(null, { tunnels: tunnels }); } if (params.relayers.length &lt; constants.MAX_FIND_TUNNEL_RELAYS) { return this._askNeighborsForTunnels(params.relayers, callback); } callback(null, { tunnels: tunnels }); }; /** * Sends a FIND_TUNNEL to our seed on behalf of requester * @private */ Protocol.prototype._askNeighborsForTunnels = function(relayers, callback) { var self = this; var nearestNeighbors = this._network._router.getNearestContacts( this._network._contact.nodeID, 3, this._network._contact.nodeID ).filter(function(contact) { return relayers.indexOf(contact.nodeID) === -1; }); this._logger.info('asking nearest neighbors for known tunnels'); function askNeighbor(neighbor, done) { self._network._transport.send(neighbor, kad.Message({ method: 'FIND_TUNNEL', params: { contact: self._network._contact, relayers: [self._network.contact].concat(relayers) } }), function(err, response) { if (err || !Array.isArray(response.result.tunnels)) { return done(null, false); } if (response.result.tunnels &amp;&amp; response.result.tunnels.length) { response.result.tunnels.forEach(function(tun) { if (self._network._tunnelers.getSize() &lt; kad.constants.K) { self._network._tunnelers.addContact( self._network._transport._createContact(tun) ); } }); return done(null, true); } done(null, false); }); } async.detectSeries(nearestNeighbors, askNeighbor, function() { callback(null, { tunnels: self._network._tunnelers.getContactList() }); }); }; /** * Handles OPEN_TUNNEL messages * @private * @param {Object} params * @param {Function} callback */ Protocol.prototype._handleOpenTunnel = function(params, callback) { var self = this; this._logger.info('opening gateway for %s', params.contact.nodeID); this._network._transport._tunserver.createGateway(function(err, gateway) { if (err) { return callback(err); } var tunnel = [ 'ws://', self._network._contact.address, ':', self._network._transport._tunserver.getListeningPort(), '/tun?token=', gateway.getEntranceToken() ].join(''); var alias = { address: self._network._contact.address, port: gateway.getEntranceAddress().port }; self._logger.info( 'gateway opened for %s at %j', params.contact.nodeID, alias ); if (self._network._transport._isPublic) { return callback(null, { tunnel: tunnel, alias: alias }); } self._network._transport.createPortMapping( gateway.getEntranceAddress().port, function(err) { if (err) { return callback(err); } callback(null, { tunnel: tunnel, alias: alias }); } ); }); }; /** * Returns bound references to the protocol handlers * @returns {Object} handlers */ Protocol.prototype.handlers = function() { return { OFFER: this._handleOffer.bind(this), AUDIT: this._handleAudit.bind(this), CONSIGN: this._handleConsign.bind(this), RETRIEVE: this._handleRetrieve.bind(this), PROBE: this._handleProbe.bind(this), FIND_TUNNEL: this._handleFindTunnel.bind(this), OPEN_TUNNEL: this._handleOpenTunnel.bind(this) }; }; module.exports = Protocol; × Search results Close "},"lib_storage_adapters_ram.js.html":{"id":"lib_storage_adapters_ram.js.html","title":"Source: lib/storage/adapters/ram.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/adapters/ram.js 'use strict'; var inherits = require('util').inherits; var stream = require('readable-stream'); var StorageAdapter = require('../adapter'); var StorageItem = require('../item'); /** * Implements an in-memory storage adapter * @extends {StorageAdapter} * @constructor */ function RAMStorageAdapter() { if (!(this instanceof RAMStorageAdapter)) { return new RAMStorageAdapter(); } this._items = {}; this._shards = {}; } inherits(RAMStorageAdapter, StorageAdapter); /** * Implements the abstract {@link StorageAdapter#_get} * @private * @param {String} key * @param {Function} callback */ RAMStorageAdapter.prototype._get = function(key, callback) { var self = this; var result = this._items[key]; if (!result) { return callback(new Error('Shard data not found')); } if (this._shards[key]) { result.shard = new stream.Readable({ read: function() { if (this._finished) { this.push(null); } else { this.push(self._shards[key]); this._finished = true; } } }); } else { result.shard = new stream.Writable({ write: function(data, encoding, next) { self._shards[key] = data; next(); } }); } callback(null, new StorageItem(result)); }; /** * Implements the abstract {@link StorageAdapter#_peek} * @private * @param {String} key * @param {Function} callback */ RAMStorageAdapter.prototype._peek = function(key, callback) { if (!this._items[key]) { return callback(new Error('Shard data not found')); } callback(null, new StorageItem(this._items[key])); }; /** * Implements the abstract {@link StorageAdapter#_put} * @private * @param {String} key * @param {StorageItem} item * @param {Function} callback */ RAMStorageAdapter.prototype._put = function(key, item, callback) { this._items[key] = item; callback(); }; /** * Implements the abstract {@link StorageAdapter#_del} * @private * @param {String} key * @param {Function} callback */ RAMStorageAdapter.prototype._del = function(key, callback) { delete this._shards[key]; callback(); }; /** * Implements the abstract {@link StorageAdapter#_size} * @private * @param {Function} callback */ RAMStorageAdapter.prototype._size = function(callback) { var shardBytes = 0; for (var key in this._shards) { shardBytes += this._shards[key].length; } callback( null, Buffer(JSON.stringify(this._items)).length + shardBytes ); }; /** * Implements the abstract {@link StorageAdapter#_keys} * @private * @param {Function} callback */ RAMStorageAdapter.prototype._keys = function(callback) { callback(null, Object.keys(this._items)); }; module.exports = RAMStorageAdapter; × Search results Close "},"lib_network_ratelimiter.js.html":{"id":"lib_network_ratelimiter.js.html","title":"Source: lib/network/ratelimiter.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/ratelimiter.js 'use strict'; var merge = require('merge'); var ms = require('ms'); /** * Tracks the number of messages received from a given nodeID and prevents * handling of message received during the limited timespan * @constructor * @param {Object} options * @param {Number} options.rate - The number of milliseconds before resetting * @param {Number} options.limit - The number of messages allowed per rate */ function RateLimiter(options) { if (!(this instanceof RateLimiter)) { return new RateLimiter(options); } options = merge(Object.create(RateLimiter.DEFAULTS), options); this.rate = options.rate; this.limit = options.limit; this.started = Date.now(); this.resetCounter(); setInterval(this.resetCounter.bind(this), this.rate); } RateLimiter.DEFAULTS = { rate: ms('1m'), limit: 120 }; /** * Increment the counter for the given nodeID * @param {String} nodeID - The nodeID of the contact to track */ RateLimiter.prototype.updateCounter = function(nodeID) { this._counter[nodeID] = (this._counter[nodeID] || 0) + 1; }; /** * Checks if the given nodeID is currently rate limited * @param {String} nodeID - The nodeID for the contact to check * @returns {Boolean} */ RateLimiter.prototype.isLimited = function(nodeID) { return this._counter[nodeID] ? this._counter[nodeID] &gt; this.limit : false; }; /** * Resets the rate limit count */ RateLimiter.prototype.resetCounter = function() { this._counter = {}; }; /** * Returns the time left before counter reset * @returns {Number} */ RateLimiter.prototype.getResetTime = function() { return this.rate - ((Date.now() - this.started) % this.rate); }; module.exports = RateLimiter; × Search results Close "},"lib_interfaces_renter.js.html":{"id":"lib_interfaces_renter.js.html","title":"Source: lib/interfaces/renter.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/interfaces/renter.js 'use strict'; var assert = require('assert'); var Contract = require('../contract'); var Contact = require('../network/contact'); var AuditStream = require('../auditstream'); var kad = require('kad'); var Network = require('../network'); var inherits = require('util').inherits; var StorageItem = require('../storage/item'); /** * Creates and a new farmer interface * @constructor * @extends {Network} */ function RenterInterface(options) { if (!(this instanceof RenterInterface)) { return new RenterInterface(options); } Network.call(this, options); } inherits(RenterInterface, Network); /** * Publishes a storage {@link Contract} for solicitation of offers based on the * supplied shard metadata. * @param {Contract} contract - Proposed storage contract to solicit for offers * @param {RenterInterface~getStorageOfferCallback} callback - Offer handler */ RenterInterface.prototype.getStorageOffer = function(contract, callback) { assert(contract instanceof Contract, 'Invalid contract supplied'); assert(typeof callback === 'function', 'Invalid offer handler supplied'); this._pendingContracts[contract.get('data_hash')] = callback; this.publish(contract.getTopicString(), contract.toObject(), { key: contract.get('data_hash') }); }; /** * This callback is called upon receipt of an offer from * {@link RenterInterface#getStorageOffer} * @callback RenterInterface~getStorageOfferCallback * @param {Contact} farmer - The farmer who offered to fulfill the contract * @param {Contract} contract - The {@link Contact} offered by the farmer */ /** * Issues an audit request to the given farmer for the data and returns the * {@link ProofStream#getProofResult} structure for verification. * @param {Contact} farmer - Farmer contact from which proof is needed * @param {StorageItem} item - The storage item on which to perform the audit * @param {RenterInterface~getStorageProofCallback} callback - Proof handler */ RenterInterface.prototype.getStorageProof = function(farmer, item, callback) { assert(farmer instanceof Contact, 'Invalid contact supplied'); assert(item instanceof StorageItem, 'Invalid storage item supplied'); if (!item.challenges[farmer.nodeID]) { return callback(new Error('Item has no contracts with supplied farmer')); } if (!item.challenges[farmer.nodeID].challenges.length) { return callback(new Error('There are no remaining challenges to send')); } var message = new kad.Message({ method: 'AUDIT', params: { audits: [ { data_hash: item.hash, challenge: item.challenges[farmer.nodeID].challenges.shift() } ], contact: this._contact } }); this._transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } if (!Array.isArray(response.result.proofs)) { return callback(new Error('Invalid proof returned')); } callback(null, response.result.proofs[0]); }); }; /** * This callback is called upon receipt of an audit proof from * {@link RenterInterface#getStorageProof} * @callback RenterInterface~getStorageProofCallback * @param {Error|null} err - If requesting the proof failed, an error object * @param {Array} proof - Result from {@link ProofStream#getProofResult} */ /** * Requests a consignment token from the given farmer for opening a * {@link DataChannelClient} for transferring the the data shard to the farmer * @param {Contact} farmer - The farmer contact object for requesting token * @param {Contract} contract - The storage contract for this consignment * @param {AuditStream} audit - The audit object for merkle leaves * @param {RenterInterface~getConsignTokenCallback} callback - Token handler */ RenterInterface.prototype.getConsignToken = function(f, c, a, callback) { var farmer = f; var contract = c; var audit = a; assert(farmer instanceof Contact, 'Invalid farmer contact supplied'); assert(contract instanceof Contract, 'Invalid contract supplied'); assert(audit instanceof AuditStream, 'Invalid audit object supplied'); var message = new kad.Message({ method: 'CONSIGN', params: { data_hash: contract.get('data_hash'), audit_tree: audit.getPublicRecord(), contact: this._contact } }); this._transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } callback(null, response.result.token); }); }; /** * This callback is called upon receipt of a consignment token from * {@link RenterInterface#getConsignToken} * @callback RenterInterface~getConsignTokenCallback * @param {Error|null} err - If requesting the token failed, an error object * @param {String} token - Consignment token for a {@link DataChannelClient} */ /** * Requests a retrieval token from the given farmer for opening a * {@link DataChannelClient} for transferring the data shard from the farmer * @param {Contact} farmer - The farmer contact object for requesting token * @param {Contract} contract - The storage contract for this consignment * @param {RenterInterface~getRetrieveTokenCallback} callback - Token handler */ RenterInterface.prototype.getRetrieveToken = function(f, c, callback) { var farmer = f; var contract = c; assert(farmer instanceof Contact, 'Invalid farmer contact supplied'); assert(contract instanceof Contract, 'Invalid contract supplied'); var message = new kad.Message({ method: 'RETRIEVE', params: { data_hash: contract.get('data_hash'), contact: this._contact } }); this._transport.send(farmer, message, function(err, response) { if (err) { return callback(err); } if (response.error) { return callback(new Error(response.error.message)); } callback(null, response.result.token); }); }; /** * This callback is called upon receipt of a retrieval token from * {@link RenterInterface#getRetrieveToken} * @callback RenterInterface~getRetrieveTokenCallback * @param {Error|null} err - If requesting the token failed, an error object * @param {String} token - Consignment token for a {@link DataChannelClient} */ module.exports = RenterInterface; × Search results Close "},"lib_storage_item.js.html":{"id":"lib_storage_item.js.html","title":"Source: lib/storage/item.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/item.js 'use strict'; var assert = require('assert'); var Contract = require('../contract'); var merge = require('merge'); /** * Represents a storage item, including contracts, challenges, the shard itself * along with metadata describing download count, payments, etc * @constructor * @param {Object} data * @param {String|null} data.hash - Shard hash to use as storage key * @param {Stream|null} data.shard - Raw binary blob of shard * @param {Object} data.contracts - Dictionary of nodeID:{@link Contract} * @param {Object} data.trees - Dictionary of nodeID:merkleLeaves * @param {Object} data.challenges - Dictionary of nodeID:privateAuditData * @param {Object} data.meta - Dictionary of arbitrary nodeID:metadata */ function StorageItem(data) { if (!(this instanceof StorageItem)) { return new StorageItem(data); } data = merge({}, data); this.hash = null; this.shard = null; this.contracts = {}; this.trees = data.trees || {}; this.challenges = data.challenges || {}; this.meta = data.meta || {}; this.modified = data.modified || Date.now(); this._init(data); } /** * Adds the trees and challenges to the item keyed by nodeID * @param {Contact} contact - The contact associated with the trees * @param {Audit|AuditStream} audit - The audit or challenge generator */ StorageItem.prototype.addAuditRecords = function(contact, audit) { this.trees[contact.nodeID] = audit.getPublicRecord(); this.challenges[contact.nodeID] = audit.getPrivateRecord(); }; /** * Adds the contract data keyed by nodeID * @param {Contact} contact - The contact associated with the trees * @param {Contract} contract - The storage contract instance */ StorageItem.prototype.addContract = function(contact, contract) { this.contracts[contact.nodeID] = contract; }; /** * Adds the meta data keyed by nodeID * @param {Contact} contact - The contact associated with the trees * @param {Object} meta - Arbitrary metadata about the shard */ StorageItem.prototype.addMetaData = function(contact, meta) { this.meta[contact.nodeID] = meta; }; /** * Updates the timestamp for the item */ StorageItem.prototype.updateTimestamp = function() { this.modified = Date.now(); }; /** * Initializes the item values with the given data * @private * @param {Object} data * @returns {StorageItem} */ StorageItem.prototype._init = function(data) { assert(typeof data === 'object', 'Invalid item data supplied'); this.shard = data.shard || null; this.hash = data.hash || null; for (var nodeID in data.contracts) { this.contracts[nodeID] = new Contract(data.contracts[nodeID]); } return this; }; module.exports = StorageItem; × Search results Close "},"lib_storage_migration.js.html":{"id":"lib_storage_migration.js.html","title":"Source: lib/storage/migration.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/storage/migration.js 'use strict'; var assert = require('assert'); var StorageAdapter = require('./adapter'); var inherits = require('util').inherits; var EventEmitter = require('events').EventEmitter; var StorageItem = require('./item'); /** * Migrates data stored with one {@link StorageAdapter} to another * @constructor * @param {StorageAdapter} source - The source adapter * @param {StorageAdapter} target - The migration destination */ function StorageMigration(source, target) { if (!(this instanceof StorageMigration)) { return new StorageMigration(source, target); } assert(source instanceof StorageAdapter, 'Invalid storage adapter supplied'); assert(target instanceof StorageAdapter, 'Invalid storage adapter supplied'); this.source = source; this.target = target; this.readyState = StorageMigration.STOPPED; EventEmitter.call(this); } inherits(StorageMigration, EventEmitter); StorageMigration.STOPPED = 0; StorageMigration.STARTED = 1; /** * Starts the migration process */ StorageMigration.prototype.start = function() { assert( this.readyState === StorageMigration.STOPPED, 'Migration has already started' ); this.readyState = StorageMigration.STARTED; this._sourceStream = this.source.createReadStream(); this._sourceStream.on('data', this._handleSourceObject.bind(this)); this._sourceStream.on('end', this._handleSourceFinished.bind(this)); this._sourceStream.on('error', this._handleSourceError.bind(this)); return this._sourceStream; }; /** * Stops the migration process */ StorageMigration.prototype.stop = function() { assert( this.readyState === StorageMigration.STARTED, 'Migration has already stopped' ); this._sourceStream.removeAllListeners(); this.readyState = StorageMigration.STOPPED; this._sourceStream = null; }; /** * Handles a data event from the source read stream and inserts it into the * the target adapter * @private * @param {StorageItem} sourceItem - Storage item from the source read stream */ StorageMigration.prototype._handleSourceObject = function(sourceItem) { var self = this; self._sourceStream.pause(); self.target.put(StorageItem(sourceItem), function(err) { if (err) { return self.emit('error', err); } self.target.get(sourceItem.hash, function(err, targetItem) { if (err) { return self.emit('error', err); } self.source.get(sourceItem.hash, function(err, fullSourceItem) { if (err) { return self.emit('error', err); } if (typeof fullSourceItem.shard.read === 'function') { return fullSourceItem.shard.pipe(targetItem.shard) .on('error', self._handleSourceError.bind(this)) .on('finish', self._sourceStream.resume.bind(self._sourceStream)); } self._sourceStream.resume(); }); }); }); }; /** * Handles the completion of the source stream read * @private */ StorageMigration.prototype._handleSourceFinished = function() { this.readyState = StorageMigration.STOPPED; this._sourceStream = null; this.emit('finish'); }; /** * Handles errors received from the underyling source stream * @private * @param {Error} error */ StorageMigration.prototype._handleSourceError = function(err) { this.readyState = StorageMigration.STOPPED; this._sourceStream = null; this.emit('error', err); }; module.exports = StorageMigration; × Search results Close "},"lib_network_transport.js.html":{"id":"lib_network_transport.js.html","title":"Source: lib/network/transport.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/network/transport.js 'use strict'; var inherits = require('util').inherits; var kad = require('kad'); var portfinder = require('portfinder'); var natupnp = require('nat-upnp'); var ip = require('ip'); var TunnelServer = require('../tunnel/server'); var merge = require('merge'); var utils = require('../utils'); /** * Custom HTTP transport adapter * @constructor * @param {kad.Contact} contact - Contact object to binding to port * @param {Object} options * @param {Logger} options.logger - Logger for diagnositcs * @param {Boolean} options.cors - Enable cross origin resource sharing * @param {Number} options.tunnels - Number of tunnels to provide to network * @param {Boolean} options.noforward - Do not try to punch out of NAT * @param {Number} options.tunport - Port for tunnel server to listen on * @param {Object} options.gateways * @param {Number} options.gateways.min - Min port for gateway binding * @param {Number} options.gateways.max - Max port for gateway binding */ function Transport(contact, options) { if (!(this instanceof Transport)) { return new Transport(contact, options); } options = merge(Object.create(Transport.DEFAULTS), options); this._maxTunnels = options.tunnels; this._tunport = options.tunport || 0; this._noforward = options.noforward; this._gateways = options.gateways; kad.transports.HTTP.call(this, contact, options); this._bindTunnelServer(); } Transport.DEFAULTS = { maxTunnels: 3, tunport: 0, noforward: false, gateways: { min: 0, max: 0 } }; inherits(Transport, kad.transports.HTTP); /** * Opens the transport, trying UPnP to become publicly addressable and falling * back to using a Tunnel * @private * @param {Function} callback */ Transport.prototype._open = function(callback) { var self = this; if (ip.isPublic(self._contact.address) || self._noforward) { self._isPublic = true; return kad.transports.HTTP.prototype._open.call(self, callback); } self._log.warn( 'you are not bound to a public address, trying traversal strategies...' ); self._forwardPort(function(err, ip, port) { self._isPublic = !err; kad.transports.HTTP.prototype._open.call(self, callback); self._contact.port = port || self._contact.port; self._contact.address = ip || self._contact.address; }); }; /** * Creates a port mapping with UPnP * @param {Number} port - The port to forward * @param {Function} callback - Callback function */ Transport.prototype.createPortMapping = function(port, callback) { var self = this; var natupnpClient = natupnp.createClient(); natupnpClient.portMapping({ public: port, private: port, ttl: 0 }, function(err) { if (err) { self._log.warn('could not connect to NAT device via UPnP'); return callback(err); } natupnpClient.externalIp(function(err, ip) { if (err) { self._log.warn('could not obtain public IP address'); return callback(err); } self._log.info('successfully traversed NAT via UPnP'); callback(null, ip, port); }); }); }; /** * resolve random port * @private * @param {Number} port * @param {Function} callback */ Transport.prototype._getPort = function(callback) { var self = this; if (self._contact.port) { return callback(null, self._contact.port); } portfinder.basePort = Math.floor(Math.random() * (65535 - 1024) + 1024); portfinder.getPort(callback); }; /** * Forwards a port and resolves the public IP * @private * @param {Function} callback */ Transport.prototype._forwardPort = function(callback) { var self = this; self._getPort(function(err, port) { if (err) { self._log.warn('could not obtain port'); return callback(err); } self.createPortMapping(port, callback); }); }; /** * Set up a local tunnel server * @private */ Transport.prototype._bindTunnelServer = function() { var self = this; this._log.info( 'you are configured to tunnel up to %s connections', this._maxTunnels || TunnelServer.DEFAULTS.maxTunnels ); this._tunserver = new TunnelServer({ maxTunnels: this._maxTunnels, port: this._tunport, portRange: this._gateways }); this._tunserver.on('ready', function() { if (self._isPublic) { return; } self.createPortMapping(this.getListeningPort(), function(err, ip, port) { if (err) { self._log.error('failed to map port for tunserver: %s', err.message); } else { self._log.info('tunnel server bound and port mapped: %s', port); } }); }); }; /** * Validates the supplied contact * @private */ Transport.prototype.send = function(contact, message, callback) { if (kad.Message.isResponse(message)) { return kad.transports.HTTP.prototype.send.apply(this, arguments); } if (!utils.isValidContact(contact, !!process.env.STORJ_ALLOW_LOOPBACK)) { return callback(new Error('Invalid or forbidden contact address')); } kad.transports.HTTP.prototype.send.apply(this, arguments); }; module.exports = Transport; × Search results Close "},"lib_tunnel_client.js.html":{"id":"lib_tunnel_client.js.html","title":"Source: lib/tunnel/client.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/tunnel/client.js 'use strict'; var kad = require('kad'); var assert = require('assert'); var WebSocketClient = require('ws'); var TunnelMuxer = require('./multiplexer'); var TunnelDemuxer = require('./demultiplexer'); var events = require('events'); var inherits = require('util').inherits; var request = require('request'); var url = require('url'); /** * Creates a tunnel connection to a {@link TunnelServer} * @constructor * @param {String} tunnel - URI for remote tunnel * @param {String} target - Local address/port for forwarding tunneled messages */ function TunnelClient(tunnel, target) { if (!(this instanceof TunnelClient)) { return new TunnelClient(tunnel, target); } assert(typeof tunnel === 'string', 'Invalid tunnel address supplied'); assert(typeof target === 'string', 'Invalid target address supplied'); this._tunuri = tunnel; this._target = target; this._tunnel = null; this._muxer = null; this._demuxer = null; this._channels = {}; events.EventEmitter.call(this); } /** * Triggered when the tunnel is opened * @event TunnelClient#open */ /** * Triggered when the tunnel is closed * @event TunnelClient#close */ inherits(TunnelClient, events.EventEmitter); /** * Opens the tunnel connection */ TunnelClient.prototype.open = function() { var self = this; this._demuxer = new TunnelDemuxer(); this._muxer = new TunnelMuxer(); this._tunnel = new WebSocketClient(this._tunuri); this._demuxer.on('error', function(err) { self.emit('error', err); }); this._demuxer.on('data', function(object) { switch (object.type) { case 'rpc': self._handleRPC(object); break; case 'datachannel': self._handleDataChannel(object); break; default: self.emit('error', new Error('Cannot handle tunnel frame type')); } }); this._muxer.on('error', function(err) { self.emit('error', err); }); this._muxer.on('data', function(buffer) { self._tunnel.send(buffer, { binary: true }); }); this._tunnel.on('error', function(err) { self.close(); self.emit('error', err); }); this._tunnel.on('close', function() { self.close(); }); this._tunnel.on('open', function() { self.emit('open'); }); this._tunnel.on('message', function(data) { self._demuxer.write(data); }); }; /** * Closes the tunnel connection */ TunnelClient.prototype.close = function() { if (!this._tunnel) { return this.emit('error', new Error('Tunnel is not open')); } var states = [WebSocketClient.CONNECTING, WebSocketClient.OPEN]; this._muxer.removeAllListeners(); this._demuxer.removeAllListeners(); if (states.indexOf(this._tunnel.readyState) !== -1) { this._tunnel.close(); } this._tunnel = null; this.emit('close'); }; /** * Handles incoming RPC messages and forwards them to the target, proxying the * response back through to the tunnel server * @private * @param {Object} object - The demuxed message object */ TunnelClient.prototype._handleRPC = function(object) { var options = { url: this._target, method: 'POST', body: object.data.serialize() }; request(options, this._forwardResponse.bind(this)); }; /** * Buffers the supplied response stream and sends it through the multiplexer * and back to the tunnel server * @private * @param {http.ServerResponse} res */ TunnelClient.prototype._forwardResponse = function(err, res, body) { if (err) { return this.emit('error', err); } this._muxer.write({ type: 'rpc', data: kad.Message.fromBuffer(Buffer(body)), flags: {} }); }; /** * Handles incoming datachannel messages and forwards them to the target, * proxying the response back through to the tunnel server * @private * @param {Object} object - The demuxed message object */ TunnelClient.prototype._handleDataChannel = function(object) { var self = this; var urlobj = url.parse(this._target); var destination = 'ws://' + urlobj.hostname + ':' + urlobj.port; var quid = object.flags.quid; if (this._channels[object.flags.quid]) { return this._sendToExistingSocket(object); } var socket = this._channels[quid] = new WebSocketClient(destination); socket.on('open', function() { socket.send(object.data, { binary: object.flags.binary }); }); socket.on('error', function(err) { self.emit('error', err); }); socket.on('message', function(data, flags) { self._muxer.write({ type: 'datachannel', data: data, flags: { binary: flags.binary, quid: quid } }); }); socket.on('close', function() { delete self._channels[quid]; }); }; /** * Sends the object to an already open socket * @private */ TunnelClient.prototype._sendToExistingSocket = function(object) { var sock = this._channels[object.flags.quid]; if (sock.readyState !== WebSocketClient.OPEN) { return sock.once('open', function() { sock.send(object.data, { binary: object.flags.binary }); }); } return sock.send(object.data, { binary: object.flags.binary }); }; module.exports = TunnelClient; × Search results Close "},"lib_tunnel_demultiplexer.js.html":{"id":"lib_tunnel_demultiplexer.js.html","title":"Source: lib/tunnel/demultiplexer.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/tunnel/demultiplexer.js 'use strict'; var stream = require('readable-stream'); var kad = require('kad'); var inherits = require('util').inherits; var constants = require('../constants'); /** * Demultiplexes a multiplexed tunnel stream * @constructor */ function TunnelDemuxer() { if (!(this instanceof TunnelDemuxer)) { return new TunnelDemuxer(); } stream.Transform.call(this, { objectMode: true }); } inherits(TunnelDemuxer, stream.Transform); /** * Parses and demultiplexes RPC messages * @private * @param {Buffer} buffer - The RPC data to demux * @param {Function} callback */ TunnelDemuxer.prototype._demuxRPC = function(buffer, callback) { callback(null, { type: 'rpc', data: kad.Message.fromBuffer(buffer.slice(1)), flags: {} }); }; /** * Parses and demultiplexes datachannel messages * @private * @param {Buffer} buffer - The datachannel data to demux * @param {Function} callback */ TunnelDemuxer.prototype._demuxDataChannel = function(buffer, callback) { if ([0x01, 0x02].indexOf(buffer[1]) === -1) { return callback(new Error('Invalid frame type opcode supplied')); } var binary = buffer[1] === 0x02; // NB: WebSocket opcode for frame type var data = buffer.slice(8); callback(null, { type: 'datachannel', data: binary ? data : data.toString(), flags: { binary: binary, quid: buffer.slice(2, 8).toString('hex') } }); }; /** * Input transformer * @private */ TunnelDemuxer.prototype._transform = function(buffer, encoding, callback) { switch (buffer[0]) { case constants.OPCODE_TUNRPC_PREFIX: return this._demuxRPC(buffer, callback); case constants.OPCODE_TUNDCX_PREFIX: return this._demuxDataChannel(buffer, callback); default: return callback(new Error('Invalid input for tunnel demuxing')); } }; module.exports = TunnelDemuxer; × Search results Close "},"lib_interfaces_tunneler.js.html":{"id":"lib_interfaces_tunneler.js.html","title":"Source: lib/interfaces/tunneler.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/interfaces/tunneler.js 'use strict'; var Network = require('../network'); var inherits = require('util').inherits; var merge = require('merge'); var Manager = require('../manager'); var RAMStorageAdapter = require('../storage/adapters/ram'); /** * Creates a new tunneler interface (a passive non-renter/non-farmer node) and * is just a {@link Network} instance, with more appropriate default options * including an in-memory storage adapter. * @constructor * @extends {Network} * @param {Object} options * @param {KeyPair} options.keypair - Node's cryptographic identity * @param {Object} options.logger - Optional logger override * @param {Array} options.seeds - List of seed URIs to join * @param {String} options.address - Public node IP or hostname * @param {Number} options.port - Listening port for RPC * @param {Boolean} options.noforward - Flag for skipping traversal strategies * @param {Number} options.tunnels - Max number of tunnels to provide * @param {Number} options.tunport - Port for tunnel server to use * @param {Object} options.gateways * @param {Number} options.gateways.min - Min port for gateway binding * @param {Number} options.gateways.max - Max port for gateway binding */ function TunnelerInterface(options) { if (!(this instanceof TunnelerInterface)) { return new TunnelerInterface(options); } options = merge(Object.create(TunnelerInterface.DEFAULTS), options); Network.call(this, merge(options, { manager: new Manager(new RAMStorageAdapter()) })); } inherits(TunnelerInterface, Network); TunnelerInterface.DEFAULTS = merge(Object.create(Network.DEFAULTS), { tunnels: 24, port: 8080, tunport: 8081, gatways: { min: 0, max: 0 }, noforward: true // NB: Tunnelers generally should be public already }); module.exports = TunnelerInterface; × Search results Close "},"lib_tunnel_gateway.js.html":{"id":"lib_tunnel_gateway.js.html","title":"Source: lib/tunnel/gateway.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/tunnel/gateway.js 'use strict'; var kad = require('kad'); var http = require('http'); var https = require('https'); var ws = require('ws'); var events = require('events'); var inherits = require('util').inherits; var crypto = require('crypto'); /** * Creates a tunnel gateway and emits manages entry and exit messages * @constructor * @param {Object} options - Options to pass to http.Server/https.Server * @param {Number} port - Port to bind gateway entrance * @fires TunnelGateway#message/rpc * @fires TunnelGateway#message/datachannel */ function TunnelGateway(options, port) { if (!(this instanceof TunnelGateway)) { return new TunnelGateway(options, port); } this._port = port || 0; this._options = options || {}; this._server = this._options.cert &amp;&amp; this._options.key ? https.createServer(this._options, this._handleRPC.bind(this)) : http.createServer(this._handleRPC.bind(this)); this._websock = new ws.Server({ server: this._server }); // Manages pending RPC responses this._responses = {}; // Manages open data channel sockets this._channels = {}; this.token = crypto.randomBytes(32).toString('hex'); } /** * Triggered when a message is received over RPC * @event TunnelGateway#message/rpc * @param {Object} message - The parsed RPC message received */ /** * Triggered when the gateway is opened * @event TunnelGateway#open */ /** * Triggered when the gateway is closed * @event TunnelGateway#close */ /** * Triggered when a message is received over a datachannel * @event TunnelGateway#message/datachannel * @param {Buffer|String} data - The data frame received * @param {Object} flags - WebSocket flags included * @param {Boolean} flags.binary - Frame was sent with 0x02 opcode * @param {String} flags.quid - Quasi-unique ID assigned to this socket */ inherits(TunnelGateway, events.EventEmitter); /** * Returns the alias data for the gateway * @returns {Object|null} alias */ TunnelGateway.prototype.getEntranceAddress = function() { var addr = this._server.address(); if (addr === null) { return addr; } return { address: addr.address, port: addr.port }; }; /** * Returns the authorization token for this gateway * @returns {Object} alias */ TunnelGateway.prototype.getEntranceToken = function() { return this.token; }; /** * Dispatches the supplied response the the given pending RPC by ID * @param {Object} message - The JSON-RPC message response * @returns {Boolean} sent - Whether or not the message was sent */ TunnelGateway.prototype.respond = function(message) { var response = kad.Message(message); if (!this._responses[message.id]) { return false; } try { this._responses[message.id].end(response.serialize()); delete this._responses[message.id]; } catch (err) { return false; } return true; }; /** * Writes the supplied data to the socket at the given quid * @param {String} quid - The quasi-unique socket identifier * @param {String|Buffer} - The data to be transferred * @returns {Boolean} sent - Whether or not the data was transferred */ TunnelGateway.prototype.transfer = function(quid, data) { var flags = { binary: Buffer.isBuffer(data) }; if (!this._channels[quid]) { return false; } try { this._channels[quid].send(data, flags); } catch (err) { return false; } return true; }; /** * Terminates the specified channel * @param {String} quid - The quasi-unique socket identifier * @returns {Boolean} terminated - Whether or not the channel was terminated */ TunnelGateway.prototype.terminate = function(quid) { if (!this._channels[quid]) { return false; } try { this._channels[quid].close(); } catch (err) { return false; } return true; }; /** * Opens the gateway * @param {Function} callback - Optional completion callback */ TunnelGateway.prototype.open = function(callback) { var self = this; if (callback) { this.once('open', callback); } this._server.listen(this._port, function() { self._websock.on('connection', self._handleDataChannel.bind(self)); self._onGatewayOpen(); }); }; /** * Closes the gateway * @param {Function} callback - Optional completion callback */ TunnelGateway.prototype.close = function(callback) { var self = this; if (callback) { this.once('close', callback); } try { this._shutdown(); } catch (err) { // noop } this._responses = {}; this._channels = {}; setImmediate(function() { self.emit('close'); }); }; /** * Forces a gateway shutdown * @private */ TunnelGateway.prototype._shutdown = function() { this._websock.close(); this._server.close(); for (var id in this._responses) { this._responses[id].end(); } for (var quid in this._channels) { this._channels[quid].close(); } }; /** * Handles incoming RPC messages * @private */ TunnelGateway.prototype._handleRPC = function(req, res) { var self = this; var message = new Buffer([]); req.on('data', function(chunk) { message = Buffer.concat([message, chunk]); }); req.on('end', function() { try { message = kad.Message.fromBuffer(message); } catch (err) { res.writeHead(400); return res.end(); } self._responses[message.id] = res; // Keep track of this response self.emit('message/rpc', message); }); }; /** * Handles incoming data channel connections * @private */ TunnelGateway.prototype._handleDataChannel = function(socket) { var self = this; var quid = crypto.randomBytes(6).toString('hex'); this._channels[quid] = socket; socket.on('message', function(data, flags) { flags.quid = quid; self.emit('message/datachannel', data, flags); }); socket.on('close', function() { delete self._channels[quid]; }); }; /** * Fired when server begins listening * @private */ TunnelGateway.prototype._onGatewayOpen = function() { var self = this; setImmediate(function() { self.emit('open', self.getEntranceToken(), self.getEntranceAddress()); }); }; module.exports = TunnelGateway; × Search results Close "},"lib_tunnel_multiplexer.js.html":{"id":"lib_tunnel_multiplexer.js.html","title":"Source: lib/tunnel/multiplexer.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/tunnel/multiplexer.js 'use strict'; var stream = require('readable-stream'); var inherits = require('util').inherits; var constants = require('../constants'); /** * Multiplexes events from a {@link TunnelGateway} and exposes a readable * stream to piped down to a {@link TunnelClient} (and vice-versa). * @constructor */ function TunnelMuxer() { if (!(this instanceof TunnelMuxer)) { return new TunnelMuxer(); } stream.Transform.call(this, { objectMode: true }); } inherits(TunnelMuxer, stream.Transform); /** * Set up event listeners for a {@link TunnelGateway} or {@link TunnelClient} * @param {TunnelGateway|TunnelClient} source - Input source to add * @returns {TunnelGateway|TunnelClient} source */ TunnelMuxer.prototype.source = function(source) { var self = this; source.on('message/rpc', function(message) { self.write({ type: 'rpc', data: message, flags: {} }); }); source.on('message/datachannel', function(data, flags) { self.write({ type: 'datachannel', data: data, flags: flags }); }); return (this._source = source); }; /** * Parses and multiplexes RPC messages * @private * @param {kad.Message} message - The RPC message to mux * @param {Function} callback */ TunnelMuxer.prototype._muxRPC = function(message, callback) { callback(null, Buffer.concat([ Buffer([constants.OPCODE_TUNRPC_PREFIX]), message.serialize() ])); }; /** * Parses and multiplexes datachannel messages * @private * @param {Buffer|String} data - The included data in the datachannel message * @param {Object} flags - Metadata about the message * @param {Function} callback */ TunnelMuxer.prototype._muxDataChannel = function(data, flags, callback) { callback(null, Buffer.concat([ Buffer([constants.OPCODE_TUNDCX_PREFIX]), Buffer([flags.binary ? 0x02 : 0x01]), // NB: WebSocket opcode for frame type Buffer(flags.quid, 'hex'), Buffer(data) ])); }; /** * Input transformer * @private */ TunnelMuxer.prototype._transform = function(object, encoding, callback) { switch (object.type) { case 'rpc': return this._muxRPC(object.data, callback); case 'datachannel': return this._muxDataChannel(object.data, object.flags, callback); default: return callback(new Error('Invalid input for tunnel muxing')); } }; module.exports = TunnelMuxer; × Search results Close "},"lib_tunnel_server.js.html":{"id":"lib_tunnel_server.js.html","title":"Source: lib/tunnel/server.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/tunnel/server.js 'use strict'; var TunnelGateway = require('./gateway'); var TunnelMuxer = require('./multiplexer'); var TunnelDemuxer = require('./demultiplexer'); var ws = require('ws'); var merge = require('merge'); var url = require('url'); var qs = require('querystring'); var events = require('events'); var inherits = require('util').inherits; /** * Creates a Tunnel server for NATed or firewalled clients to use to join the * overlay network. * @constructor * @param {Object} options * @param {http.Server} options.server - Transport adapter to bind to * @param {Number} options.port - Port to bind if no server provided * @param {Number} options.maxTunnels - Maximum number of gateways to open * @param {Object} options.portRange * @param {Number} options.portRange.min - Starting port to allow gateways * @param {Number} options.portRange.max - Ending port to allow gateways */ function TunnelServer(options) { if (!(this instanceof TunnelServer)) { return new TunnelServer(options); } this._options = merge(Object.create(TunnelServer.DEFAULTS), options); this._serveropts = { path: '/tun', verifyClient: this._verifyClient.bind(this) }; this._server = new ws.Server( this._options.server ? merge(this._serveropts, { server: this._options.server }) : merge(this._serveropts, { port: this._options.port }) ); this._gateways = {}; // NB: {@link TunnelGateway}s keyed by their token this._authorized = []; // NB: List of authorized tokens this._usedPorts = []; this._server.on('connection', this._handleClient.bind(this)); this._server._server.on('listening', this._emitReady.bind(this)); events.EventEmitter.call(this); } /** * Triggered when the server is listening * @event TunnelServer#ready */ /** * Triggered when the server has no more available tunnels * @event TunnelServer#locked */ /** * Triggered when the server has an available tunnel * @event TunnelServer#unlocked */ inherits(TunnelServer, events.EventEmitter); TunnelServer.DEFAULTS = { port: 0, server: null, maxTunnels: 3, portRange: { min: 0, // NB: 0 means use any port max: 0 // NB: 0 means use any port } }; /** * Creates a new {@link TunnelGateway} and prepares it for use * @param {Function} callback - Called on {@link TunnelGateway#event:open} */ TunnelServer.prototype.createGateway = function(callback) { if (Object.keys(this._gateways).length === this._options.maxTunnels) { return callback(new Error('Maximum number of tunnels open')); } var self = this; // TODO: Pass in SSL options into first arg if provided var gateway = new TunnelGateway({}, this._getAvailablePort()); var authID = gateway.getEntranceToken(); var usedPort = null; gateway.on('close', function() { delete self._gateways[authID]; self._usedPorts.splice(self._usedPorts.indexOf(usedPort), 1); self.emit('unlocked'); }); gateway.on('open', function(token) { authID = token; self._gateways[authID] = gateway; usedPort = gateway.getEntranceAddress().port; self._usedPorts.push(usedPort); if (Object.keys(self._gateways).length === self._options.maxTunnels) { self.emit('locked'); } self._authorized.push(authID); callback(null, gateway); }); gateway.open(); }; /** * Returns whether or not this tunnel server has any available tunnels * @returns {Boolean} */ TunnelServer.prototype.hasTunnelAvailable = function() { return Object.keys(this._gateways).length !== this._options.maxTunnels; }; /** * Returns the port the tunnel server is listening on * @returns {Number} port */ TunnelServer.prototype.getListeningPort = function() { return this._server._server.address().port; }; /** * Handles the verfication of a connecting client by the supplied token * @private * @param {Object} info * @param {Function} callback * @see https://github.com/websockets/ws/blob/master/doc/ws.md */ TunnelServer.prototype._verifyClient = function(info, callback) { var token = this._extractTokenFromRequest(info.req); if (this._authorized.indexOf(token) === -1) { return callback(false, 401); } this._authorized.splice(this._authorized.indexOf(token), 1); callback(true); }; /** * Returns an available port, suitable for opening a gateway * @private */ TunnelServer.prototype._getAvailablePort = function() { if (!this._options.portRange.min) { return 0; } var start = this._options.portRange.min; var end = this._options.portRange.max; var available = []; while (start &lt;= end) { available.push(start++); } for (var i = 0; i &lt; this._usedPorts.length; i++) { if (available.indexOf(this._usedPorts[i]) !== -1) { available.splice(available.indexOf(this._usedPorts[i]), 1); } } return available[Math.floor(Math.random() * available.length)]; }; /** * Extracts the token from the request url * @private * @param {http.IncomingMessage} req */ TunnelServer.prototype._extractTokenFromRequest = function(req) { var uriobj = url.parse(req.url); var query = qs.parse(uriobj.query); return query.token; }; /** * Emits the ready event * @private */ TunnelServer.prototype._emitReady = function() { this.emit('ready'); }; /** * Handles an authorized client connection and connects it the the appropriate * {@link TunnelGateway} and associated {@link TunnelDemuxer} * @private * @param {WebSocket} client */ TunnelServer.prototype._handleClient = function(client) { var token = this._extractTokenFromRequest(client.upgradeReq); if (!this._gateways[token]) { return client.close(404, { error: 'Gateway no longer open' }); } var gateway = this._gateways[token]; var muxer = new TunnelMuxer(); var demuxer = new TunnelDemuxer(); function cleanup() { gateway.close(); demuxer.removeAllListeners(); muxer.removeAllListeners(); } demuxer .on('error', function(err) { client.close(400, { error: err.message }); }) .on('data', function(object) { switch (object.type) { case 'rpc': return gateway.respond(object.data); case 'datachannel': return gateway.transfer(object.flags.quid, object.data); default: client.close(400, { error: 'Cannot handle tunnel frame type' }); } }); muxer .on('error', function(err) { client.close(400, { error: err.message }); }) .on('data', function(data) { client.send(data, { binary: true }); }) .source(gateway); client .on('message', function(data) { demuxer.write(data); }) .on('close', cleanup) .on('error', cleanup); }; module.exports = TunnelServer; × Search results Close "},"lib_unpadder.js.html":{"id":"lib_unpadder.js.html","title":"Source: lib/unpadder.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/unpadder.js 'use strict'; var stream = require('readable-stream'); var inherits = require('util').inherits; /** * Takes an input stream and removes padded zeroes from the tail * @constructor */ function Unpadder() { if (!(this instanceof Unpadder)) { return new Unpadder(); } stream.Transform.call(this); } inherits(Unpadder, stream.Transform); /** * Implements the transformer * @private */ Unpadder.prototype._transform = function(chunk, enc, callback) { var firstNullByte = chunk.indexOf(0); var lastNullByte = chunk.lastIndexOf(0); var lastByteIsNull = lastNullByte === chunk.length - 1; var expectedPadding = Buffer(lastNullByte - firstNullByte).fill(0); var possiblePadding = chunk.slice(firstNullByte, lastNullByte); var sectionIsNull = Buffer.compare(expectedPadding, possiblePadding) === 0; var isPadding = sectionIsNull &amp;&amp; lastByteIsNull; if (isPadding) { callback(null, chunk.slice(0, firstNullByte)); } else { callback(null, chunk); } }; module.exports = Unpadder; × Search results Close "},"lib_verification.js.html":{"id":"lib_verification.js.html","title":"Source: lib/verification.js","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Source: lib/verification.js 'use strict'; var assert = require('assert'); var utils = require('./utils'); /** * Interface for verifying the result of an audit proof * @constructor * @param {Array} proof - The result of {@link ProofStream#getProofResult} */ function Verification(proof) { if (!(this instanceof Verification)) { return new Verification(proof); } assert(Array.isArray(proof), 'Proof must be an array'); this._proof = proof; } /** * Extracts the challenge response from the proof * @private * @param {Array} response - Challenge response received from farmer * @returns {String} leaf */ Verification.prototype._getChallengeResponse = function(tuple) { var data = tuple || this._proof; if (data.length === 1) { return utils.rmd160sha256(data[0]); } if (Array.isArray(data[0])) { return this._getChallengeResponse(data[0]); } else { return this._getChallengeResponse(data[1]); } }; /** * Verifies the proof given the merkle root and tree depth * @param {String} root - Merkle root * @param {Number} totaldepth - Depth of merkle tree * @returns {Array} result - Array with expected result and verified result */ Verification.prototype.verify = function(root, totaldepth) { function _collapse(proof, leaf, depth) { if (depth === 0) { assert(proof.length === 1, 'Invalid proof structure'); assert(utils.rmd160sha256(proof[0]) === leaf, 'Invalid proof value'); return leaf; } var hashL, hashR; if (Array.isArray(proof[0])) { hashL = _collapse(proof[0], leaf, depth - 1); } else { hashL = proof[0]; } if (Array.isArray(proof[1])) { hashR = _collapse(proof[1], leaf, depth - 1); } else { hashR = proof[1]; } return utils.rmd160sha256(hashL + hashR); } return [ _collapse(this._proof, this._getChallengeResponse(), totaldepth - 1), root ]; }; module.exports = Verification; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Modules Classes AuditStream BridgeClient Contact Contract DataChannelClient DataChannelServer DataCipherKeyIv DecryptStream EncryptStream FarmerInterface FileDemuxer FileMuxer KeyPair KeyRing LevelDBFileStore LevelDBStorageAdapter Manager Network Padder ProofStream Protocol RAMStorageAdapter RateLimiter RenterInterface StorageAdapter StorageItem StorageMigration Transport TunnelClient TunnelDemuxer TunnelerInterface TunnelGateway TunnelMuxer TunnelServer Unpadder Verification Events finish Triggered when the stream has ended Source: lib/auditstream.js data Triggered when some input bytes have become decrypted output bytes Type: Buffer Source: lib/cryptostream/decrypt.js end Triggered when the stream has ended Source: lib/cryptostream/decrypt.js data Triggered when some input bytes have become encrypted output bytes Type: Buffer Source: lib/cryptostream/encrypt.js end Triggered when the stream has ended Source: lib/cryptostream/encrypt.js ready Ready event is triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js finish Triggered when the demuxer has finished writing to all shards Source: lib/filedemuxer.js shard Triggered when the demuxer has a shard ready to stream Parameters: Name Type Description shard ReadableStream The file shard as a readable stream Source: lib/filedemuxer.js drain Triggered when the muxer has drained one of the supplied inputs Parameters: Name Type Description input ReadableStream The drained input stream Source: lib/filemuxer.js locked Triggered when the underlying storage adapter reaches capacity Source: lib/manager.js unlocked Triggered when the underlying storage adapter has newly freed space Source: lib/manager.js ready Ready event is triggered when the transport's network interface is ready Source: lib/network/index.js ready Ready event is triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js close Triggered when the tunnel is closed Source: lib/tunnel/client.js open Triggered when the tunnel is opened Source: lib/tunnel/client.js ready Ready event is triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js close Triggered when the gateway is closed Source: lib/tunnel/gateway.js message/datachannel Triggered when a message is received over a datachannel Parameters: Name Type Description data Buffer | String The data frame received flags Object WebSocket flags included Properties Name Type Description binary Boolean Frame was sent with 0x02 opcode quid String Quasi-unique ID assigned to this socket Source: lib/tunnel/gateway.js message/rpc Triggered when a message is received over RPC Parameters: Name Type Description message Object The parsed RPC message received Source: lib/tunnel/gateway.js open Triggered when the gateway is opened Source: lib/tunnel/gateway.js locked Triggered when the server has no more available tunnels Source: lib/tunnel/server.js ready Triggered when the server is listening Source: lib/tunnel/server.js unlocked Triggered when the server has an available tunnel Source: lib/tunnel/server.js × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Classes Classes AuditStream BridgeClient Contact Contract DataChannelClient DataChannelServer DataCipherKeyIv DecryptStream EncryptStream FarmerInterface FileDemuxer FileMuxer KeyPair KeyRing LevelDBFileStore LevelDBStorageAdapter Manager Network Padder ProofStream Protocol RAMStorageAdapter RateLimiter RenterInterface StorageAdapter StorageItem StorageMigration Transport TunnelClient TunnelDemuxer TunnelerInterface TunnelGateway TunnelMuxer TunnelServer Unpadder Verification Events finish Triggered when the stream has ended Source: lib/auditstream.js data Triggered when some input bytes have become decrypted output bytes Type: Buffer Source: lib/cryptostream/decrypt.js end Triggered when the stream has ended Source: lib/cryptostream/decrypt.js data Triggered when some input bytes have become encrypted output bytes Type: Buffer Source: lib/cryptostream/encrypt.js end Triggered when the stream has ended Source: lib/cryptostream/encrypt.js ready Ready event is triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js finish Triggered when the demuxer has finished writing to all shards Source: lib/filedemuxer.js shard Triggered when the demuxer has a shard ready to stream Parameters: Name Type Description shard ReadableStream The file shard as a readable stream Source: lib/filedemuxer.js drain Triggered when the muxer has drained one of the supplied inputs Parameters: Name Type Description input ReadableStream The drained input stream Source: lib/filemuxer.js locked Triggered when the underlying storage adapter reaches capacity Source: lib/manager.js unlocked Triggered when the underlying storage adapter has newly freed space Source: lib/manager.js ready Ready event is triggered when the transport's network interface is ready Source: lib/network/index.js ready Ready event is triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js close Triggered when the tunnel is closed Source: lib/tunnel/client.js open Triggered when the tunnel is opened Source: lib/tunnel/client.js ready Ready event is triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js close Triggered when the gateway is closed Source: lib/tunnel/gateway.js message/datachannel Triggered when a message is received over a datachannel Parameters: Name Type Description data Buffer | String The data frame received flags Object WebSocket flags included Properties Name Type Description binary Boolean Frame was sent with 0x02 opcode quid String Quasi-unique ID assigned to this socket Source: lib/tunnel/gateway.js message/rpc Triggered when a message is received over RPC Parameters: Name Type Description message Object The parsed RPC message received Source: lib/tunnel/gateway.js open Triggered when the gateway is opened Source: lib/tunnel/gateway.js locked Triggered when the server has no more available tunnels Source: lib/tunnel/server.js ready Triggered when the server is listening Source: lib/tunnel/server.js unlocked Triggered when the server has an available tunnel Source: lib/tunnel/server.js × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Tutorials Classes AuditStream BridgeClient Contact Contract DataChannelClient DataChannelServer DataCipherKeyIv DecryptStream EncryptStream FarmerInterface FileDemuxer FileMuxer KeyPair KeyRing LevelDBFileStore LevelDBStorageAdapter Manager Network Padder ProofStream Protocol RAMStorageAdapter RateLimiter RenterInterface StorageAdapter StorageItem StorageMigration Transport TunnelClient TunnelDemuxer TunnelerInterface TunnelGateway TunnelMuxer TunnelServer Unpadder Verification Events finish Triggered when the stream has ended Source: lib/auditstream.js data Triggered when some input bytes have become decrypted output bytes Type: Buffer Source: lib/cryptostream/decrypt.js end Triggered when the stream has ended Source: lib/cryptostream/decrypt.js data Triggered when some input bytes have become encrypted output bytes Type: Buffer Source: lib/cryptostream/encrypt.js end Triggered when the stream has ended Source: lib/cryptostream/encrypt.js ready Ready event is triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js finish Triggered when the demuxer has finished writing to all shards Source: lib/filedemuxer.js shard Triggered when the demuxer has a shard ready to stream Parameters: Name Type Description shard ReadableStream The file shard as a readable stream Source: lib/filedemuxer.js drain Triggered when the muxer has drained one of the supplied inputs Parameters: Name Type Description input ReadableStream The drained input stream Source: lib/filemuxer.js locked Triggered when the underlying storage adapter reaches capacity Source: lib/manager.js unlocked Triggered when the underlying storage adapter has newly freed space Source: lib/manager.js ready Ready event is triggered when the transport's network interface is ready Source: lib/network/index.js ready Ready event is triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js close Triggered when the tunnel is closed Source: lib/tunnel/client.js open Triggered when the tunnel is opened Source: lib/tunnel/client.js ready Ready event is triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js close Triggered when the gateway is closed Source: lib/tunnel/gateway.js message/datachannel Triggered when a message is received over a datachannel Parameters: Name Type Description data Buffer | String The data frame received flags Object WebSocket flags included Properties Name Type Description binary Boolean Frame was sent with 0x02 opcode quid String Quasi-unique ID assigned to this socket Source: lib/tunnel/gateway.js message/rpc Triggered when a message is received over RPC Parameters: Name Type Description message Object The parsed RPC message received Source: lib/tunnel/gateway.js open Triggered when the gateway is opened Source: lib/tunnel/gateway.js locked Triggered when the server has no more available tunnels Source: lib/tunnel/server.js ready Triggered when the server is listening Source: lib/tunnel/server.js unlocked Triggered when the server has an available tunnel Source: lib/tunnel/server.js × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections This package exposes a module that provides all of the tools needed to integrate with the Storj network. Complete documentation can be found here. Prerequisites Node.js v4.x.x Git Python v2.x.x Installing on GNU/Linux &amp; Mac OSXInstall Node.js and it's package manager NPM using Node Version Manager: curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.1/install.sh | bash Detailed NVM installation instructions can be found here. After NVM is installed, source your ~/.bashrc, ~/.profile, or ~/.zshrc depending on your shell of choice: source ~/.zshrcNow that you can call the nvm program, install Node.js (which comes with NPM): nvm install 4.4.4 You'll also need to make sure you have a C++ compiler installed before proceeding to the next step. Debian based distributions can install the build-essential package using APT and Mac OSX users can install with xcode-select --install and follow the wizard. Installing on WindowsDownload Node.js LTS for Windows, launch the installer and follow the setup instructions. Restart your PC, then test it from the command prompt: node --version npm --versionInstall the latest version of Python 2.7, launch the installer and follow the instructions. To use Python from the shell and add it to the system you have to add the path in &quot;System Variables&quot;: Navigate to: Control Panel &gt; System &gt; Advanced System Settings &gt; Environment Variables &gt; System Variables &gt; Path &gt; EditThen add ;C:\\Python27 or the installation path and test it in the command prompt by running: python -VNext, install Git for your Windows version. Then, install Visual Studio Community 2015 and during the setup choose Custom Installation &gt; Programming Languages and select Visual C++ and Common Tools for Visual C++. Finally, set the new environment variable in the Windows command prompt with: setx GYP_MSVS_VERSION 2015Quick Start (Programmatic)Install locally as user with NPM: npm install storj --saveImport the storj module, generate a key pair, configure your persistence layer, and join the network in just a few lines of code: var storj = require('storj'); var network = storj.Network({ keypair: storj.KeyPair(/* existing_key */), manager: storj.Manager(storj.LevelDBStorageAdapter('/path/to/datadir')), address: 'ip.or.hostname', port: 4000 }); network.join(/* callback */);Quick Start (Command Line Interface)Install globally as user with NPM: npm install storj --globalUse the linked command line interface: storj --helpLicenseStorj Core - Implementation of the Storj protocol for Node.js Copyright (C) 2016 Storj Labs, Inc This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;. × Search results Close "},"AuditStream.html":{"id":"AuditStream.html","title":"Class: AuditStream","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: AuditStream AuditStream new AuditStream(audits) Represents a streaming audit challenge generator Parameters: Name Type Description audits Number Total number of challenges to generate Source: lib/auditstream.js Fires: AuditStream#event:finish Methods &lt;static&gt; fromRecords(challenges, tree) Returns a new instance from the predefined challenges and tree Parameters: Name Type Description challenges Array The precomputed challenges tree Array The bottom leaves of the existing merkle tree Source: lib/auditstream.js Returns: Type AuditStream getPrivateRecord() Returns the challenges, the tree depth, and merkle root Source: lib/auditstream.js Returns: challenge - Private audit record with challenges Type Object getPublicRecord() Returns the bottom leaves of the merkle tree for sending to farmer Source: lib/auditstream.js Returns: leaves - Bottom merkle leaves of audit tree Type Array Events finish Triggered when the stream has ended Source: lib/auditstream.js × Search results Close "},"BridgeClient.html":{"id":"BridgeClient.html","title":"Class: BridgeClient","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: BridgeClient BridgeClient new BridgeClient(uri, options) Represents a client interface to a given bridge server Parameters: Name Type Description uri String API base URI ('https://api.storj.io') options Object Properties Name Type Description keypair KeyPair KeyPair instance for request signing basicauth Object Properties Name Type Description email String Email address for HTTP basic auth password String Password for HTTP basic auth Source: lib/bridgeclient.js See: https://github.com/storj/bridge Methods addPublicKey(pubkey, callback) Registers a public key for the caller Parameters: Name Type Description pubkey String Hex encoded ECDSA (secp256k1) public key callback function Source: lib/bridgeclient.js addShardToFileStagingFrame(id, shard, callback) Creates a file staging frame Parameters: Name Type Description id String Unique frame ID shard Object The shard metadata callback function Source: lib/bridgeclient.js createBucket(data, callback) Creates a new file bucket Parameters: Name Type Description data Object Bucket parameters for creation callback function Source: lib/bridgeclient.js createFileStagingFrame(callback) Creates a file staging frame Parameters: Name Type Description callback function Source: lib/bridgeclient.js createToken(id, operation, callback) Create bucket token Parameters: Name Type Description id String Unique bucket ID operation String PUSH or PULL (file operation) callback function Source: lib/bridgeclient.js createUser(options, callback) Registers a user account Parameters: Name Type Description options Object Properties Name Type Description email String Email address for verification email password String Password to register (auto hashed) redirect String URL to redirect to after verification pubkey String Optional ECDSA public key to register callback function Source: lib/bridgeclient.js destroyBucketById(id, callback) Removes the bucket Parameters: Name Type Description id String Unique bucket ID callback function Source: lib/bridgeclient.js destroyFileStagingFrameById(id, callback) Creates a file staging frame Parameters: Name Type Description id String Unique frame ID callback function Source: lib/bridgeclient.js destroyPublicKey(pubkey, callback) Disassociates the public key from the caller Parameters: Name Type Description pubkey String Hex encoded ECDSA (secp256k1) public key callback function Source: lib/bridgeclient.js getBucketById(id, callback) Returns the bucket information by ID Parameters: Name Type Description id String Unique bucket ID callback function Source: lib/bridgeclient.js getBuckets(callback) Lists the caller's file buckets Parameters: Name Type Description callback function Source: lib/bridgeclient.js getContactByNodeId(nodeId, callback) Get the contact information for the given nodeID Parameters: Name Type Description nodeId String The nodeID of the contact callback function Source: lib/bridgeclient.js getContactList(options, callback) Fetches the list of known contacts filtered according to the options Parameters: Name Type Description options Object Properties Name Type Description page Number The page number of the contact list to fetch connected Boolean Filter results by connection status callback function Source: lib/bridgeclient.js getFilePointer(bucket, token, fileID, callback) Retrieves a file pointer from the bucket Parameters: Name Type Description bucket String Unique bucket ID token String Token from BridgeClient#createToken fileID String The unique file pointer ID callback function Source: lib/bridgeclient.js getFileStagingFrameById(id, callback) Creates a file staging frame Parameters: Name Type Description id String Unique frame ID callback function Source: lib/bridgeclient.js getFileStagingFrames(callback) Creates a file staging frame Parameters: Name Type Description callback function Source: lib/bridgeclient.js getInfo(callback) Get the remote Storj Bridge API documentation and version as JSON Parameters: Name Type Description callback function Source: lib/bridgeclient.js getPublicKeys(callback) Returns list of associated public keys Parameters: Name Type Description callback function Source: lib/bridgeclient.js listFilesInBucket(id, callback) Lists the files stored in a bucket Parameters: Name Type Description id String Unique bucket ID callback function Source: lib/bridgeclient.js removeFileFromBucket(id, file, callback) Removes a file from a bucket Parameters: Name Type Description id String Unique bucket ID file String ID of the file to remove from bucket callback function Source: lib/bridgeclient.js resolveFileFromPointers(pointers, callback) Open a series of data channels based on the returned value of BridgeClient#getFilePointer to resolve all the shards and reassemble them together as a binary stream Parameters: Name Type Description pointers Array Result of BridgeClient#getFilePointer callback function Source: lib/bridgeclient.js storeFileInBucket(id, token, file, shards, callback) Stores a file in the bucket Parameters: Name Type Description id String Unique bucket ID token String Token from BridgeClient#createToken file String Path to file to store shards Number Number of shards to create callback function Source: lib/bridgeclient.js updateBucketById(id, updates, callback) Updates the bucket Parameters: Name Type Description id String Unique bucket ID updates Object Bucket update parameters callback function Source: lib/bridgeclient.js × Search results Close "},"Contact.html":{"id":"Contact.html","title":"Class: Contact","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Contact Contact new Contact(options) Represents a Storj contact (or peer) Parameters: Name Type Description options Object Source: lib/network/contact.js × Search results Close "},"Contract.html":{"id":"Contract.html","title":"Class: Contract","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Contract Contract new Contract(contract, criteria) Represents a storage contract between a renter and a farmer Parameters: Name Type Description contract Object Properties Name Type Description type String Unique identifier for the contract renter_id String Node ID of the renter renter_signature String Renter's cryptographic signature farmer_id String Node ID of the farmer farmer_signature String Farmer's cryptographic signature data_size Number Number of bytes to store data_hash String RIPEMD-160 SHA-256 hash of the data store_begin Number UNIX timestamp to start contract store_end Number UNIX timestamp to end the contract audit_count Number Number of audits renter will perform payment_storage_price Number Total price for storage payment_download_price Number Price per download payment_destination String Bitcoin address to send funds criteria Object Properties Name Type Description size Number Criteria degree OPCODE duration Number Criteria degree OPCODE availability Number Criteria degree OPCODE speed Number Criteria degree OPCODE Version: 0 Source: lib/contract/index.js Members &lt;static&gt; CRITERIA Defines some default criteria of a Contract Source: lib/contract/index.js &lt;static&gt; DEFAULTS Defines some default properties of a Contract Source: lib/contract/index.js &lt;static&gt; MATRIX Defines the criteria matrix for a Contract Source: lib/contract/index.js &lt;static&gt; Schema Defines the JSON Schema of a Contract Source: lib/contract/index.js Methods &lt;static&gt; compare(c1, c2) Compares two contracts against each other Parameters: Name Type Description c1 Contract Contract to compare c2 Contract Contract to compare Source: lib/contract/index.js Returns: Type Boolean &lt;static&gt; createTopic(criteria) Create a topical OPCODE byte sequence from the provided criteria Parameters: Name Type Description criteria Object Properties Name Type Description size Number Criteria degree OPCODE duration Number Criteria degree OPCODE availability Number Criteria degree OPCODE speed Number Criteria degree OPCODE Source: lib/contract/index.js Returns: Type Buffer &lt;static&gt; createValidator() Creates a validator function for data against the schema Source: lib/contract/index.js Returns: validator Type function &lt;static&gt; fromBuffer(buffer) Creates a contract from a Buffer Parameters: Name Type Description buffer Buffer Raw binary blob of contract data Source: lib/contract/index.js Returns: Type Contract &lt;static&gt; fromJSON(json) Creates a contract from a JSON string Parameters: Name Type Description json String JSON encoded contract Source: lib/contract/index.js Returns: Type Contract &lt;static&gt; fromObject(object) Creates a contract from a plain object Parameters: Name Type Description object Object Dictionary of contract data Source: lib/contract/index.js Returns: Type Contract get(field_name) Returns the value for the given contract property Parameters: Name Type Description field_name String Contract property to get Source: lib/contract/index.js Returns: value Type String | Number | null getHash() Calculates the SHA-256 hash of the serialized contract Source: lib/contract/index.js Returns: Type Buffer getTopicBuffer() Return OPCODE byte sequence for contract publication topic Source: lib/contract/index.js Returns: Type Buffer getTopicString() Return OPCODE byte sequence for contract publication topic as hex string Source: lib/contract/index.js Returns: Type String isComplete() Checks if the contract is complete Source: lib/contract/index.js Returns: completed Type Boolean set(field_name) Sets the contract property to the given value Parameters: Name Type Description field_name String Contract property to get Source: lib/contract/index.js Returns: value Type String | Number | null sign(actor, secret) Signs the contract as the given actor Parameters: Name Type Description actor String One of 'farmer' or 'renter' secret Buffer ECDSA private key Source: lib/contract/index.js Returns: signature Type String toBuffer() Converts the contract to Buffer Source: lib/contract/index.js Returns: Type Buffer toJSON() Converts the contract to JSON string Source: lib/contract/index.js Returns: Type String toObject() Converts the contract to a plain object Source: lib/contract/index.js Returns: Type Object update(fields) Applies the provided fields to the contract and validates it Parameters: Name Type Description fields Object Contract properties to update Source: lib/contract/index.js Returns: self Type Contract verify(actor, pubkeyhash) Verify the contract signature for the given actor Parameters: Name Type Description actor String One of 'farmer' or 'renter' pubkeyhash Buffer ECDSA nodeID Source: lib/contract/index.js Returns: validity Type Boolean × Search results Close "},"DataChannelClient.html":{"id":"DataChannelClient.html","title":"Class: DataChannelClient","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: DataChannelClient DataChannelClient new DataChannelClient(contact) Creates a data channel client for sending and receiving consigned file shards Parameters: Name Type Description contact Object Properties Name Type Description address String The address of the target farmer port Number The port of the target farmer Source: lib/datachannel/client.js Methods &lt;static&gt; getChannelURL(contact) Returns the URI of the contact's data channel Parameters: Name Type Description contact Object Source: lib/datachannel/client.js createReadStream(token, hash) Creates a readable stream from the remote farmer for retrieval of a shard Parameters: Name Type Description token String The RETRIEVE token supplied by the farmer hash String The hash of the data to retrieve Source: lib/datachannel/client.js Returns: Type stream.Readable createWriteStream(token, hash) Creates a writable stream from the remote farmer for consignment of a shard Parameters: Name Type Description token String The CONSIGN token supplied by the farmer hash String The hash of the data to consign Source: lib/datachannel/client.js Returns: Type stream.Writable × Search results Close "},"DataChannelServer.html":{"id":"DataChannelServer.html","title":"Class: DataChannelServer","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: DataChannelServer DataChannelServer new DataChannelServer(options) Creates a data channel server for sending and receiving consigned file shards Parameters: Name Type Description options Object Properties Name Type Description server http.Server A http(s).Server instance manager Manager The Manager from Network logger kad.Logger Logger to use from Network ttl Number Close after idle for this length of time Source: lib/datachannel/server.js Methods accept(token, filehash) Begin accepting data for the given file hash and token Parameters: Name Type Description token String The authorization token created for transfer filehash String The shard hash to allow for the token Source: lib/datachannel/server.js close() Closes the data channel and disconnects all clients Source: lib/datachannel/server.js reject(token) Stop accepting data for the given token Parameters: Name Type Description token String The authorization token created for transfer Source: lib/datachannel/server.js × Search results Close "},"DataCipherKeyIv.html":{"id":"DataCipherKeyIv.html","title":"Class: DataCipherKeyIv","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: DataCipherKeyIv DataCipherKeyIv new DataCipherKeyIv(password, salt) Create a new random cipher key and initialization vector Parameters: Name Type Description password String | Buffer The unique cipher password salt String | Buffer The unique salt Source: lib/cipherkeyiv.js Methods &lt;static&gt; fromObject(object) Returns the a DataCipherKeyIv from an object Parameters: Name Type Description object Object Properties Name Type Description pass Buffer | String The unique password salt Buffer | String The unique salt Source: lib/cipherkeyiv.js Returns: Type DataCipherKeyIv getCipherKeyIv() Returns the cipher key and iv in an array Source: lib/cipherkeyiv.js Returns: Type Array toObject() Returns the key and iv as an array Source: lib/cipherkeyiv.js Returns: Type Array × Search results Close "},"DecryptStream.html":{"id":"DecryptStream.html","title":"Class: DecryptStream","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: DecryptStream DecryptStream new DecryptStream(keyiv) Represents a duplex stream capable of taking encrypted data as input and producing output decrypted by a DataCipherKeyIv Parameters: Name Type Description keyiv DataCipherKeyIv Object to use for derivation function Source: lib/cryptostream/decrypt.js Fires: DecryptStream#event:data DecryptStream#event:end Events data Triggered when some input bytes have become decrypted output bytes Type: Buffer Source: lib/cryptostream/decrypt.js end Triggered when the stream has ended Source: lib/cryptostream/decrypt.js × Search results Close "},"EncryptStream.html":{"id":"EncryptStream.html","title":"Class: EncryptStream","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: EncryptStream EncryptStream new EncryptStream(keyiv) Represents a duplex stream capable of taking cleartext data as input and producing output encrypted with DataCipherKeyIv Parameters: Name Type Description keyiv DataCipherKeyIv Object to use for derivation function Source: lib/cryptostream/encrypt.js Fires: EncryptStream#event:data EncryptStream#event:end Events data Triggered when some input bytes have become encrypted output bytes Type: Buffer Source: lib/cryptostream/encrypt.js end Triggered when the stream has ended Source: lib/cryptostream/encrypt.js × Search results Close "},"FarmerInterface.html":{"id":"FarmerInterface.html","title":"Class: FarmerInterface","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: FarmerInterface FarmerInterface new FarmerInterface(options) Creates and a new farmer interface Parameters: Name Type Description options Object Properties Name Type Description storage Object Properties Name Type Description path String File system path to store data size Number Storage size to allocate unit String Storage size unit (MB|GB|TB) payment Object Properties Name Type Description address String Optional payment address opcodes Array Optional contract opcodes to farm backend function Optional levelup backend db concurrency Number Max contracts to offer at a time negotiator FarmerInterface~negotiator Negotiation rules Source: lib/interfaces/farmer.js Extends Network Methods connect(uri, callback) Connects to the node at the given URI Parameters: Name Type Description uri String The storj protocol URI to connect callback function Called on connection or error Inherited From: Network#connect Source: lib/network/index.js getPaymentAddress() Returns the payment address supplied or the derived one from keypair Source: lib/interfaces/farmer.js Returns: Type String join(callback) Wraps the super call to Network#join to listen for contract after successfully establishing a connection to the network Parameters: Name Type Description callback function Called on successful join Overrides: Network#join Source: lib/interfaces/farmer.js leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Inherited From: Network#leave Source: lib/network/index.js publish(topic, contents, options) Publishes a topic with content to the network Parameters: Name Type Description topic String The serialized opcode topic contents Object Arbitrary publication contents options Object Options to pass to kad-quasar Inherited From: Network#publish Source: lib/network/index.js subscribe(topic, handler) Subscribes to a topic on the network Parameters: Name Type Description topic String The serialized opcode topic handler Object Function to handle received publications Inherited From: Network#subscribe Source: lib/network/index.js Type Definitions negotiator(contract) Called when a contract is found that meets subscription criteria and allows us to modify the contract terms if we desire and then uses the return value to determine if we should send the renter an offer Parameters: Name Type Description contract Contract The contract object to negotiate Source: lib/interfaces/farmer.js Returns: Type Boolean Events ready Ready event is triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js × Search results Close "},"FileDemuxer.html":{"id":"FileDemuxer.html","title":"Class: FileDemuxer","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: FileDemuxer FileDemuxer new FileDemuxer(filePath, options) Takes a single file read stream and outputs several output streams, used for &quot;shredding&quot; a file and creating muliple out destination interfaces Parameters: Name Type Description filePath String Path the file to demultiplex options Object Properties Name Type Description shardSize Number Size of each shard Source: lib/filedemuxer.js Fires: FileDemuxer#event:shard Events finish Triggered when the demuxer has finished writing to all shards Source: lib/filedemuxer.js shard Triggered when the demuxer has a shard ready to stream Parameters: Name Type Description shard ReadableStream The file shard as a readable stream Source: lib/filedemuxer.js × Search results Close "},"FileMuxer.html":{"id":"FileMuxer.html","title":"Class: FileMuxer","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: FileMuxer FileMuxer new FileMuxer(options) Accepts multiple ordered input sources and exposes them as a single contiguous readable stream. Used for re-assembly of shards. Parameters: Name Type Description options Object Properties Name Type Description shards Number Number of total shards to be multiplexed length Number Number of total bytes of input Source: lib/filemuxer.js Fires: FileMuxer#event:drain Methods input(readable) Adds an additional input stream to the multiplexer Parameters: Name Type Description readable ReadableStream Readable input stream from file shard Source: lib/filemuxer.js Events drain Triggered when the muxer has drained one of the supplied inputs Parameters: Name Type Description input ReadableStream The drained input stream Source: lib/filemuxer.js × Search results Close "},"KeyPair.html":{"id":"KeyPair.html","title":"Class: KeyPair","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: KeyPair KeyPair new KeyPair(privkey) Represents a ECDSA key pair Parameters: Name Type Description privkey String | Buffer WIF encoded ECDSA private key Source: lib/keypair.js Methods getAddress() Returns the bitcoin address version of the nodeID Source: lib/keypair.js Returns: address - Base58 encoded address Type String getNodeID() Returns the NodeID derived from the public key Source: lib/keypair.js Returns: nodeID - RIPEMD160 hash of public key Type String getPrivateKey() Returns the private key Source: lib/keypair.js Returns: key Type String getPublicKey() Returns the public key Source: lib/keypair.js Returns: key Type String sign(message, options) Signs the supplied message with the private key Parameters: Name Type Description message String | Buffer The message to sign options Object Properties Name Type Description compact Boolean Compact signature format (default: true) Source: lib/keypair.js Returns: signature Type String × Search results Close "},"KeyRing.html":{"id":"KeyRing.html","title":"Class: KeyRing","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: KeyRing KeyRing new KeyRing(filePath, passPhrase) A DataCipherKeyIv factory with file system persistence Parameters: Name Type Description filePath String Path to store keyring file passPhrase String Passphrase to encrypt/decrypt keyring Source: lib/keyring.js Methods generate(id) Returns the stored KeyPair for the given id Parameters: Name Type Description id String Generate a key for use with the given ID Source: lib/keyring.js Returns: Type KeyPair get(id) Returns the stored KeyPair for the given id Parameters: Name Type Description id String Arbitrary key ID to load Source: lib/keyring.js Returns: Type KeyPair | null set(id, keypair) Returns the stored KeyPair for the given id Parameters: Name Type Description id String Arbitrary key ID to load keypair KeyPair KeyPair instance to set Source: lib/keyring.js × Search results Close "},"LevelDBFileStore.html":{"id":"LevelDBFileStore.html","title":"Class: LevelDBFileStore","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: LevelDBFileStore LevelDBFileStore new LevelDBFileStore(db) Exposes an file read/write stream interface in/out of levelup Parameters: Name Type Description db Object Levelup database instance Source: lib/storage/adapters/level/filestore.js Methods createReadStream(key) Returns a readable stream of the file at the given key Parameters: Name Type Description key String The key for the file to read Source: lib/storage/adapters/level/filestore.js Returns: Type ReadableStream createWriteStream(key) Returns a writable stream for a file at the given key Parameters: Name Type Description key String The key for the file to read Source: lib/storage/adapters/level/filestore.js Returns: Type WritableStream exists(key, callback) Determines if the file is already stored in the db Parameters: Name Type Description key String The key for the file stored callback function Called with boolean indicating existence Source: lib/storage/adapters/level/filestore.js reset(key, callback) Deletes the file pieces from the database Parameters: Name Type Description key String The key for the file stored callback function Called with boolean indicating existence Source: lib/storage/adapters/level/filestore.js × Search results Close "},"LevelDBStorageAdapter.html":{"id":"LevelDBStorageAdapter.html","title":"Class: LevelDBStorageAdapter","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: LevelDBStorageAdapter LevelDBStorageAdapter new LevelDBStorageAdapter(path, backend) Implements an LevelDB storage adapter interface Parameters: Name Type Description path String Path to store the level db backend function Optional backend override for levelup Source: lib/storage/adapters/level/index.js Extends StorageAdapter Methods createReadStream() Calls the implemented StorageAdapter#_keys and returns a readable stream containing each stored item Inherited From: StorageAdapter#createReadStream Source: lib/storage/adapter.js Returns: Type ReadableStream del(key, callback) Calls the implemented StorageAdapter#_del Parameters: Name Type Description key String Shard hash to delete the data for callback function Called with error or StorageItem Inherited From: StorageAdapter#del Source: lib/storage/adapter.js get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#get Source: lib/storage/adapter.js peek(key, callback) Calls the implemented StorageAdapter#_peek and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#peek Source: lib/storage/adapter.js put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Inherited From: StorageAdapter#put Source: lib/storage/adapter.js size(callback) Calls the implemented StorageAdapter#_size Parameters: Name Type Description callback function Called with error or number of bytes stored Inherited From: StorageAdapter#size Source: lib/storage/adapter.js × Search results Close "},"Manager.html":{"id":"Manager.html","title":"Class: Manager","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Manager Manager new Manager(storage, options) Interface for managing contracts, shards, and audits Parameters: Name Type Description storage StorageAdapter Storage adapter to use options Object Properties Name Type Description disableReaper Boolean Don't perform periodic reaping of stale contracts maxCapacity Number Max number of bytes to allow in storage Source: lib/manager.js Extends EventEmitter Methods clean(callback) Enumerates all storage contracts and reaps stale data Parameters: Name Type Description callback function Called on complete Source: lib/manager.js load(hash, callback) Loads the storage Item at the given key Parameters: Name Type Description hash String Shard hash to load data for callback function Called with error or StorageItem Source: lib/manager.js save(item, callback) Saves the storage StorageItem at the given key Parameters: Name Type Description item StorageItem The StorageItem to store callback function Called on complete Source: lib/manager.js Events locked Triggered when the underlying storage adapter reaches capacity Source: lib/manager.js unlocked Triggered when the underlying storage adapter has newly freed space Source: lib/manager.js × Search results Close "},"module-storj.html":{"id":"module-storj.html","title":"Module: storj","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj Source: index.js Members &lt;static&gt; AuditStream AuditStream Source: index.js &lt;static&gt; BridgeClient BridgeClient Source: index.js &lt;static&gt; constants constants Source: index.js &lt;static&gt; Contact Contact Source: index.js &lt;static&gt; Contract Contract Source: index.js &lt;static&gt; DataChannelClient DataChannelClient Source: index.js &lt;static&gt; DataChannelServer DataChannelServer Source: index.js &lt;static&gt; DataCipherKeyIv DataCipherKeyIv Source: index.js &lt;static&gt; DecryptStream DecryptStream Source: index.js &lt;static&gt; EncryptStream EncryptStream Source: index.js &lt;static&gt; FarmerInterface FarmerInterface Source: index.js &lt;static&gt; FileDemuxer FileDemuxer Source: index.js &lt;static&gt; FileMuxer FileMuxer Source: index.js &lt;static&gt; KeyPair KeyPair Source: index.js &lt;static&gt; KeyRing KeyRing Source: index.js &lt;static&gt; LevelDBStorageAdapter LevelDBStorageAdapter Source: index.js &lt;static&gt; Manager Manager Source: index.js &lt;static&gt; Network Network Source: index.js &lt;static&gt; Padder Padder Source: index.js &lt;static&gt; ProofStream ProofStream Source: index.js &lt;static&gt; Protocol Protocol Source: index.js &lt;static&gt; RAMStorageAdapter RAMStorageAdapter Source: index.js &lt;static&gt; RateLimiter RateLimiter Source: index.js &lt;static&gt; RenterInterface RenterInterface Source: index.js &lt;static&gt; StorageAdapter StorageAdapter Source: index.js &lt;static&gt; StorageItem StorageItem Source: index.js &lt;static&gt; StorageMigration StorageMigration Source: index.js &lt;static&gt; Transport Transport Source: index.js &lt;static&gt; Tunnel TunnelServer Source: index.js &lt;static&gt; TunnelClient TunnelClient Source: index.js &lt;static&gt; TunnelDemuxer TunnelDemuxer Source: index.js &lt;static&gt; TunnelerInterface TunnelerInterface Source: index.js &lt;static&gt; TunnelMuxer TunnelMuxer Source: index.js &lt;static&gt; Unpadder Unpadder Source: index.js &lt;static&gt; utils utils Source: index.js &lt;static&gt; Verification Verification Source: index.js × Search results Close "},"module-storj_constants.html":{"id":"module-storj_constants.html","title":"Module: storj/constants","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/constants Source: lib/constants.js Members &lt;inner, constant&gt; AUDIT_BYTES :Number Number of bytes for audit challenge Type: Number Source: lib/constants.js &lt;inner, constant&gt; CIPHER_ALG :String Cipher/Decipher algorithm Type: String Source: lib/constants.js &lt;inner, constant&gt; CLEAN_INTERVAL :Number Interval for reaping stale shards Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_CONCURRENT_AUDITS :Number Number of concurrent audits Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_CONCURRENT_OFFERS :Number Number of concurrent offers Type: Number Source: lib/constants.js &lt;inner, constant&gt; MAX_FIND_TUNNEL_RELAYS Source: lib/constants.js &lt;inner, constant&gt; NONCE_EXPIRE :Number Time to honor a signed message Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_CONTRACT_PREFIX :Number Prefix opcode for contracts Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_HIGH :Number Opcode for medium criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_LOW :Number Opcode for low criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_MED :Number Opcode for medium criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_DEG_NULL :Number Opcode for null criteria degree Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_TUNDCX_PREFIX :Number Opcode for tunnel datachannel Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_TUNNELER_PREFIX :Number Prefix opcode for tunneler Type: Number Source: lib/constants.js &lt;inner, constant&gt; OPCODE_TUNRPC_PREFIX :Number Opcode for tunnel rpc message Type: Number Source: lib/constants.js &lt;inner, constant&gt; PREFIX :Number NodeID prefix (same as bitcoin) Type: Number Source: lib/constants.js &lt;inner, constant&gt; SUBSCRIBE_THROTTLE :Number Wait between opcode subscribe Type: Number Source: lib/constants.js &lt;inner, constant&gt; TUNNEL_ANNOUNCE_INTERVAL :Number Announce tunnel state Type: Number Source: lib/constants.js × Search results Close "},"module-storj_utils.html":{"id":"module-storj_utils.html","title":"Module: storj/utils","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Module: storj/utils Source: lib/utils.js Methods &lt;static&gt; createEciesCipher(privateKey, publicKey) Creates an ECIES ciper object from a private and a public key Parameters: Name Type Description privateKey String The private key of the sender publicKey String The public key of the recipient Source: lib/utils.js Returns: Type Object &lt;static&gt; generateToken() Generates a unique token Source: lib/utils.js Returns: Type String &lt;static&gt; getContactURL(contact) Returns a stringified URL from the supplied contact object Parameters: Name Type Description contact Object Properties Name Type Description address String port Number nodeID String Source: lib/utils.js Returns: Type String &lt;static&gt; getNextPowerOfTwo(number) Returns the next power of two number Parameters: Name Type Description number Number Source: lib/utils.js Returns: Type Number &lt;static&gt; isCompatibleVersion(version) Returns whether or not the supplied semver tag is compatible Parameters: Name Type Description version String The semver tag from the contact Source: lib/utils.js Returns: compatible Type Boolean &lt;static&gt; isValidContact(contact, loopback) Determines if the supplied contact is valid Parameters: Name Type Description contact Contact The contact information for a given peer loopback Boolean Allows contacts that are localhost Source: lib/utils.js Returns: Type Boolean &lt;static&gt; rmd160(input) Returns the RIPEMD-160 hash of the input Parameters: Name Type Description input String | Buffer Data to hash Source: lib/utils.js Returns: Type String &lt;static&gt; rmd160sha256(input) Returns the RIPEMD-160 SHA-256 hash of this input Parameters: Name Type Description input String | Buffer Data to hash Source: lib/utils.js Returns: Type String &lt;static&gt; sha256(input) Returns the SHA-256 hash of the input Parameters: Name Type Description input String | Buffer Data to hash Source: lib/utils.js Returns: Type String &lt;static&gt; toNumberBytes(size, unit) Returns number of bytes from human readable size and unit strings Parameters: Name Type Description size String | Number The size measurement unit String The unit of measure (MB|GB|TB) Source: lib/utils.js Returns: Type Number × Search results Close "},"Network.html":{"id":"Network.html","title":"Class: Network","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Network Network new Network(options) Storj network interface Parameters: Name Type Description options Object Properties Name Type Description keypair KeyPair Node's cryptographic identity manager Manager Persistence management interface bridge String URL for bridge server seed lookup logger Object Logger instance seeds Array List of seed URIs to join address String Public node IP or hostname port Number Listening port for RPC noforward Boolean Flag for skipping traversal strategies tunnels Number Max number of tunnels to provide tunport Number Port for tunnel server to use gateways Object Properties Name Type Description min Number Min port for gateway binding max Number Max port for gateway binding limiter Object Options to pass to RateLimiter Source: lib/network/index.js Fires: Network#event:ready Methods connect(uri, callback) Connects to the node at the given URI Parameters: Name Type Description uri String The storj protocol URI to connect callback function Called on connection or error Source: lib/network/index.js join(callback) Opens the connection to the network Parameters: Name Type Description callback function Called on successful network join Source: lib/network/index.js leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Source: lib/network/index.js publish(topic, contents, options) Publishes a topic with content to the network Parameters: Name Type Description topic String The serialized opcode topic contents Object Arbitrary publication contents options Object Options to pass to kad-quasar Source: lib/network/index.js subscribe(topic, handler) Subscribes to a topic on the network Parameters: Name Type Description topic String The serialized opcode topic handler Object Function to handle received publications Source: lib/network/index.js Events ready Ready event is triggered when the transport's network interface is ready Source: lib/network/index.js × Search results Close "},"Padder.html":{"id":"Padder.html","title":"Class: Padder","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Padder Padder new Padder() Takes an input stream and pads the tail with zeroes to the next byte mulitple Source: lib/padder.js × Search results Close "},"ProofStream.html":{"id":"ProofStream.html","title":"Class: ProofStream","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: ProofStream ProofStream new ProofStream(leaves, challenge) Provides interface for proving possession of a file for an AuditStream Parameters: Name Type Description leaves Array Bottom leaves of the audit merkle tree challenge String The challenge data in hex to prepend to shard Source: lib/proofstream.js Methods getProofResult() Returns the generated proof structure Source: lib/proofstream.js Returns: Type Array × Search results Close "},"Protocol.html":{"id":"Protocol.html","title":"Class: Protocol","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Protocol Protocol new Protocol(options) Defines the Storj protocol methods and mounts on a Network instance to handle Storj protocol messages Parameters: Name Type Description options Object Properties Name Type Description network Network Network instance to bind to Source: lib/network/protocol.js Methods handlers() Returns bound references to the protocol handlers Source: lib/network/protocol.js Returns: handlers Type Object × Search results Close "},"RAMStorageAdapter.html":{"id":"RAMStorageAdapter.html","title":"Class: RAMStorageAdapter","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: RAMStorageAdapter RAMStorageAdapter new RAMStorageAdapter() Implements an in-memory storage adapter Source: lib/storage/adapters/ram.js Extends StorageAdapter Methods createReadStream() Calls the implemented StorageAdapter#_keys and returns a readable stream containing each stored item Inherited From: StorageAdapter#createReadStream Source: lib/storage/adapter.js Returns: Type ReadableStream del(key, callback) Calls the implemented StorageAdapter#_del Parameters: Name Type Description key String Shard hash to delete the data for callback function Called with error or StorageItem Inherited From: StorageAdapter#del Source: lib/storage/adapter.js get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#get Source: lib/storage/adapter.js peek(key, callback) Calls the implemented StorageAdapter#_peek and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Inherited From: StorageAdapter#peek Source: lib/storage/adapter.js put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Inherited From: StorageAdapter#put Source: lib/storage/adapter.js size(callback) Calls the implemented StorageAdapter#_size Parameters: Name Type Description callback function Called with error or number of bytes stored Inherited From: StorageAdapter#size Source: lib/storage/adapter.js × Search results Close "},"RateLimiter.html":{"id":"RateLimiter.html","title":"Class: RateLimiter","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: RateLimiter RateLimiter new RateLimiter(options) Tracks the number of messages received from a given nodeID and prevents handling of message received during the limited timespan Parameters: Name Type Description options Object Properties Name Type Description rate Number The number of milliseconds before resetting limit Number The number of messages allowed per rate Source: lib/network/ratelimiter.js Methods getResetTime() Returns the time left before counter reset Source: lib/network/ratelimiter.js Returns: Type Number isLimited(nodeID) Checks if the given nodeID is currently rate limited Parameters: Name Type Description nodeID String The nodeID for the contact to check Source: lib/network/ratelimiter.js Returns: Type Boolean resetCounter() Resets the rate limit count Source: lib/network/ratelimiter.js updateCounter(nodeID) Increment the counter for the given nodeID Parameters: Name Type Description nodeID String The nodeID of the contact to track Source: lib/network/ratelimiter.js × Search results Close "},"RenterInterface.html":{"id":"RenterInterface.html","title":"Class: RenterInterface","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: RenterInterface RenterInterface new RenterInterface() Creates and a new farmer interface Source: lib/interfaces/renter.js Extends Network Methods connect(uri, callback) Connects to the node at the given URI Parameters: Name Type Description uri String The storj protocol URI to connect callback function Called on connection or error Inherited From: Network#connect Source: lib/network/index.js getConsignToken(farmer, contract, audit, callback) Requests a consignment token from the given farmer for opening a DataChannelClient for transferring the the data shard to the farmer Parameters: Name Type Description farmer Contact The farmer contact object for requesting token contract Contract The storage contract for this consignment audit AuditStream The audit object for merkle leaves callback RenterInterface~getConsignTokenCallback Token handler Source: lib/interfaces/renter.js getRetrieveToken(farmer, contract, callback) Requests a retrieval token from the given farmer for opening a DataChannelClient for transferring the data shard from the farmer Parameters: Name Type Description farmer Contact The farmer contact object for requesting token contract Contract The storage contract for this consignment callback RenterInterface~getRetrieveTokenCallback Token handler Source: lib/interfaces/renter.js getStorageOffer(contract, callback) Publishes a storage Contract for solicitation of offers based on the supplied shard metadata. Parameters: Name Type Description contract Contract Proposed storage contract to solicit for offers callback RenterInterface~getStorageOfferCallback Offer handler Source: lib/interfaces/renter.js getStorageProof(farmer, item, callback) Issues an audit request to the given farmer for the data and returns the ProofStream#getProofResult structure for verification. Parameters: Name Type Description farmer Contact Farmer contact from which proof is needed item StorageItem The storage item on which to perform the audit callback RenterInterface~getStorageProofCallback Proof handler Source: lib/interfaces/renter.js join(callback) Opens the connection to the network Parameters: Name Type Description callback function Called on successful network join Inherited From: Network#join Source: lib/network/index.js leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Inherited From: Network#leave Source: lib/network/index.js publish(topic, contents, options) Publishes a topic with content to the network Parameters: Name Type Description topic String The serialized opcode topic contents Object Arbitrary publication contents options Object Options to pass to kad-quasar Inherited From: Network#publish Source: lib/network/index.js subscribe(topic, handler) Subscribes to a topic on the network Parameters: Name Type Description topic String The serialized opcode topic handler Object Function to handle received publications Inherited From: Network#subscribe Source: lib/network/index.js Type Definitions getConsignTokenCallback(err, token) This callback is called upon receipt of a consignment token from RenterInterface#getConsignToken Parameters: Name Type Description err Error | null If requesting the token failed, an error object token String Consignment token for a DataChannelClient Source: lib/interfaces/renter.js getRetrieveTokenCallback(err, token) This callback is called upon receipt of a retrieval token from RenterInterface#getRetrieveToken Parameters: Name Type Description err Error | null If requesting the token failed, an error object token String Consignment token for a DataChannelClient Source: lib/interfaces/renter.js getStorageOfferCallback(farmer, contract) This callback is called upon receipt of an offer from RenterInterface#getStorageOffer Parameters: Name Type Description farmer Contact The farmer who offered to fulfill the contract contract Contract The Contact offered by the farmer Source: lib/interfaces/renter.js getStorageProofCallback(err, proof) This callback is called upon receipt of an audit proof from RenterInterface#getStorageProof Parameters: Name Type Description err Error | null If requesting the proof failed, an error object proof Array Result from ProofStream#getProofResult Source: lib/interfaces/renter.js Events ready Ready event is triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js × Search results Close "},"StorageAdapter.html":{"id":"StorageAdapter.html","title":"Class: StorageAdapter","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: StorageAdapter StorageAdapter new StorageAdapter() Abstract base class for storage adapter Source: lib/storage/adapter.js Methods &lt;abstract&gt; _del(key, callback) Delete the shard data at the given key Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _get(key, callback) Performs lookup and provides an StorageItem to the callback Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _keys(callback) Returns the hashes of all shards stored Parameters: Name Type Description callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _peek(key, callback) Performs lookup and provides an StorageItem to the callback but does not initialize any shard read/write stream Parameters: Name Type Description key String Shard hash callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _put(key, item, callback) Stores the StorageItem Parameters: Name Type Description key String Shard hash item Item Item to store callback function Called on complete Source: lib/storage/adapter.js &lt;abstract&gt; _size(callback) Returns the number of bytes stored Parameters: Name Type Description callback function Called on complete Source: lib/storage/adapter.js createReadStream() Calls the implemented StorageAdapter#_keys and returns a readable stream containing each stored item Source: lib/storage/adapter.js Returns: Type ReadableStream del(key, callback) Calls the implemented StorageAdapter#_del Parameters: Name Type Description key String Shard hash to delete the data for callback function Called with error or StorageItem Source: lib/storage/adapter.js get(key, callback) Calls the implemented StorageAdapter#_get and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Source: lib/storage/adapter.js peek(key, callback) Calls the implemented StorageAdapter#_peek and validates the result Parameters: Name Type Description key String Shard hash to get metadata for callback function Called with error or StorageItem Source: lib/storage/adapter.js put(item, callback) Calls the implemented StorageAdapter#_put and validates the input Parameters: Name Type Description item StorageItem Item to write to storage callback function Called on complete write Source: lib/storage/adapter.js size(callback) Calls the implemented StorageAdapter#_size Parameters: Name Type Description callback function Called with error or number of bytes stored Source: lib/storage/adapter.js × Search results Close "},"StorageItem.html":{"id":"StorageItem.html","title":"Class: StorageItem","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: StorageItem StorageItem new StorageItem(data) Represents a storage item, including contracts, challenges, the shard itself along with metadata describing download count, payments, etc Parameters: Name Type Description data Object Properties Name Type Description hash String | null Shard hash to use as storage key shard Stream | null Raw binary blob of shard contracts Object Dictionary of nodeID:Contract trees Object Dictionary of nodeID:merkleLeaves challenges Object Dictionary of nodeID:privateAuditData meta Object Dictionary of arbitrary nodeID:metadata Source: lib/storage/item.js Methods addAuditRecords(contact, audit) Adds the trees and challenges to the item keyed by nodeID Parameters: Name Type Description contact Contact The contact associated with the trees audit Audit | AuditStream The audit or challenge generator Source: lib/storage/item.js addContract(contact, contract) Adds the contract data keyed by nodeID Parameters: Name Type Description contact Contact The contact associated with the trees contract Contract The storage contract instance Source: lib/storage/item.js addMetaData(contact, meta) Adds the meta data keyed by nodeID Parameters: Name Type Description contact Contact The contact associated with the trees meta Object Arbitrary metadata about the shard Source: lib/storage/item.js updateTimestamp() Updates the timestamp for the item Source: lib/storage/item.js × Search results Close "},"StorageMigration.html":{"id":"StorageMigration.html","title":"Class: StorageMigration","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: StorageMigration StorageMigration new StorageMigration(source, target) Migrates data stored with one StorageAdapter to another Parameters: Name Type Description source StorageAdapter The source adapter target StorageAdapter The migration destination Source: lib/storage/migration.js Methods start() Starts the migration process Source: lib/storage/migration.js stop() Stops the migration process Source: lib/storage/migration.js × Search results Close "},"Transport.html":{"id":"Transport.html","title":"Class: Transport","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Transport Transport new Transport(contact, options) Custom HTTP transport adapter Parameters: Name Type Description contact kad.Contact Contact object to binding to port options Object Properties Name Type Description logger Logger Logger for diagnositcs cors Boolean Enable cross origin resource sharing tunnels Number Number of tunnels to provide to network noforward Boolean Do not try to punch out of NAT tunport Number Port for tunnel server to listen on gateways Object Properties Name Type Description min Number Min port for gateway binding max Number Max port for gateway binding Source: lib/network/transport.js Methods createPortMapping(port, callback) Creates a port mapping with UPnP Parameters: Name Type Description port Number The port to forward callback function Callback function Source: lib/network/transport.js × Search results Close "},"TunnelClient.html":{"id":"TunnelClient.html","title":"Class: TunnelClient","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TunnelClient TunnelClient new TunnelClient(tunnel, target) Creates a tunnel connection to a TunnelServer Parameters: Name Type Description tunnel String URI for remote tunnel target String Local address/port for forwarding tunneled messages Source: lib/tunnel/client.js Methods close() Closes the tunnel connection Source: lib/tunnel/client.js open() Opens the tunnel connection Source: lib/tunnel/client.js Events close Triggered when the tunnel is closed Source: lib/tunnel/client.js open Triggered when the tunnel is opened Source: lib/tunnel/client.js × Search results Close "},"TunnelDemuxer.html":{"id":"TunnelDemuxer.html","title":"Class: TunnelDemuxer","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TunnelDemuxer TunnelDemuxer new TunnelDemuxer() Demultiplexes a multiplexed tunnel stream Source: lib/tunnel/demultiplexer.js × Search results Close "},"TunnelerInterface.html":{"id":"TunnelerInterface.html","title":"Class: TunnelerInterface","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TunnelerInterface TunnelerInterface new TunnelerInterface(options) Creates a new tunneler interface (a passive non-renter/non-farmer node) and is just a Network instance, with more appropriate default options including an in-memory storage adapter. Parameters: Name Type Description options Object Properties Name Type Description keypair KeyPair Node's cryptographic identity logger Object Optional logger override seeds Array List of seed URIs to join address String Public node IP or hostname port Number Listening port for RPC noforward Boolean Flag for skipping traversal strategies tunnels Number Max number of tunnels to provide tunport Number Port for tunnel server to use gateways Object Properties Name Type Description min Number Min port for gateway binding max Number Max port for gateway binding Source: lib/interfaces/tunneler.js Extends Network Methods connect(uri, callback) Connects to the node at the given URI Parameters: Name Type Description uri String The storj protocol URI to connect callback function Called on connection or error Inherited From: Network#connect Source: lib/network/index.js join(callback) Opens the connection to the network Parameters: Name Type Description callback function Called on successful network join Inherited From: Network#join Source: lib/network/index.js leave(callback) Disconnects from the network Parameters: Name Type Description callback function Called when successful disconnect Inherited From: Network#leave Source: lib/network/index.js publish(topic, contents, options) Publishes a topic with content to the network Parameters: Name Type Description topic String The serialized opcode topic contents Object Arbitrary publication contents options Object Options to pass to kad-quasar Inherited From: Network#publish Source: lib/network/index.js subscribe(topic, handler) Subscribes to a topic on the network Parameters: Name Type Description topic String The serialized opcode topic handler Object Function to handle received publications Inherited From: Network#subscribe Source: lib/network/index.js Events ready Ready event is triggered when the transport's network interface is ready Inherited From: Network#event:ready Source: lib/network/index.js × Search results Close "},"TunnelGateway.html":{"id":"TunnelGateway.html","title":"Class: TunnelGateway","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TunnelGateway TunnelGateway new TunnelGateway(options, port) Creates a tunnel gateway and emits manages entry and exit messages Parameters: Name Type Description options Object Options to pass to http.Server/https.Server port Number Port to bind gateway entrance Source: lib/tunnel/gateway.js Fires: TunnelGateway#event:message/rpc TunnelGateway#event:message/datachannel Methods close(callback) Closes the gateway Parameters: Name Type Description callback function Optional completion callback Source: lib/tunnel/gateway.js getEntranceAddress() Returns the alias data for the gateway Source: lib/tunnel/gateway.js Returns: alias Type Object | null getEntranceToken() Returns the authorization token for this gateway Source: lib/tunnel/gateway.js Returns: alias Type Object open(callback) Opens the gateway Parameters: Name Type Description callback function Optional completion callback Source: lib/tunnel/gateway.js respond(message) Dispatches the supplied response the the given pending RPC by ID Parameters: Name Type Description message Object The JSON-RPC message response Source: lib/tunnel/gateway.js Returns: sent - Whether or not the message was sent Type Boolean terminate(quid) Terminates the specified channel Parameters: Name Type Description quid String The quasi-unique socket identifier Source: lib/tunnel/gateway.js Returns: terminated - Whether or not the channel was terminated Type Boolean transfer(quid, data) Writes the supplied data to the socket at the given quid Parameters: Name Type Description quid String The quasi-unique socket identifier data String | Buffer The data to be transferred Source: lib/tunnel/gateway.js Returns: sent - Whether or not the data was transferred Type Boolean Events close Triggered when the gateway is closed Source: lib/tunnel/gateway.js message/datachannel Triggered when a message is received over a datachannel Parameters: Name Type Description data Buffer | String The data frame received flags Object WebSocket flags included Properties Name Type Description binary Boolean Frame was sent with 0x02 opcode quid String Quasi-unique ID assigned to this socket Source: lib/tunnel/gateway.js message/rpc Triggered when a message is received over RPC Parameters: Name Type Description message Object The parsed RPC message received Source: lib/tunnel/gateway.js open Triggered when the gateway is opened Source: lib/tunnel/gateway.js × Search results Close "},"TunnelMuxer.html":{"id":"TunnelMuxer.html","title":"Class: TunnelMuxer","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TunnelMuxer TunnelMuxer new TunnelMuxer() Multiplexes events from a TunnelGateway and exposes a readable stream to piped down to a TunnelClient (and vice-versa). Source: lib/tunnel/multiplexer.js Methods source(source) Set up event listeners for a TunnelGateway or TunnelClient Parameters: Name Type Description source TunnelGateway | TunnelClient Input source to add Source: lib/tunnel/multiplexer.js Returns: source Type TunnelGateway | TunnelClient × Search results Close "},"TunnelServer.html":{"id":"TunnelServer.html","title":"Class: TunnelServer","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: TunnelServer TunnelServer new TunnelServer(options) Creates a Tunnel server for NATed or firewalled clients to use to join the overlay network. Parameters: Name Type Description options Object Properties Name Type Description server http.Server Transport adapter to bind to port Number Port to bind if no server provided maxTunnels Number Maximum number of gateways to open portRange Object Properties Name Type Description min Number Starting port to allow gateways max Number Ending port to allow gateways Source: lib/tunnel/server.js Methods createGateway(callback) Creates a new TunnelGateway and prepares it for use Parameters: Name Type Description callback function Called on TunnelGateway#event:open Source: lib/tunnel/server.js getListeningPort() Returns the port the tunnel server is listening on Source: lib/tunnel/server.js Returns: port Type Number hasTunnelAvailable() Returns whether or not this tunnel server has any available tunnels Source: lib/tunnel/server.js Returns: Type Boolean Events locked Triggered when the server has no more available tunnels Source: lib/tunnel/server.js ready Triggered when the server is listening Source: lib/tunnel/server.js unlocked Triggered when the server has an available tunnel Source: lib/tunnel/server.js × Search results Close "},"Unpadder.html":{"id":"Unpadder.html","title":"Class: Unpadder","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Unpadder Unpadder new Unpadder() Takes an input stream and removes padded zeroes from the tail Source: lib/unpadder.js × Search results Close "},"Verification.html":{"id":"Verification.html","title":"Class: Verification","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Class: Verification Verification new Verification(proof) Interface for verifying the result of an audit proof Parameters: Name Type Description proof Array The result of ProofStream#getProofResult Source: lib/verification.js Methods verify(root, totaldepth) Verifies the proof given the merkle root and tree depth Parameters: Name Type Description root String Merkle root totaldepth Number Depth of merkle tree Source: lib/verification.js Returns: result - Array with expected result and verified result Type Array × Search results Close "},"tutorial-command-line-interface.html":{"id":"tutorial-command-line-interface.html","title":"Tutorial: Using the Command Line Tools","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Using the Command Line Tools This package comes equipped with a command line interface for performing a number of useful operations on the Storj network. The CLI program is generally focused on interacting with a remote Bridge service and makes use of the library's BridgeClient class to do so. In addition to interacting with a bridge node, the tool also exposes some general purpose utilities. To use the CLI, follow the instructions in the README to install the module globally or if you are working from within the git repository, you can use: npm linkCommunicating with a BridgeOnce you have access to the storj command, register and authenticate with the bridge: &gt; $ storj register [...] &gt; Enter your email address &gt; gordon@storj.io [...] &gt; Enter your password &gt; ************* [info] Registered! Check your email to activate your account.Follow the activation link you receive via email and come back to the CLI to pair with your account: &gt; $ storj login [...] &gt; Enter your email address &gt; gordon@storj.io [...] &gt; Enter your password &gt; ************* [info] This device has been successfully paired.Now you can create buckets, transfer files, and manage your bridge account. Audits, Proofs, and VerificationsThe CLI also includes some utility commands for generating file possession audits, proving possession, and verifying proofs. You can generate a challenge set and merkle tree for a file easily: &gt; $ storj prepare-audits 2 CONTRIBUTING.md [info] Generating challenges and merkle tree... [info] [info] Merkle Root [info] ----------- [info] 9c8c37935f58d46e3301efe4f44724b8785a81a5 [info] [info] Challenges [info] ---------- [info] c8573773616e072230d40131e7ce8537d384825e337e5903ff7367ddea798c52 [info] 7c4d4f57f40d5c95f962e7cd72347e4077e1885aaffd8c1ccbbd02c8d7c48dce [info] [info] Merkle Leaves [info] ------------- [info] aaf42766d87a37e6dffbae7172fd0073006bf5f3 [info] ccee086dbc8a16b93b79912cb37f3b037bbf8269A farmer can use parts of this data to prove possession of a file shard: &gt; $ storj prove-file aaf42766d87a37e6dffbae7172fd0073006bf5f3,ccee086dbc8a16b93b79912cb37f3b037bbf8269 c8573773616e072230d40131e7ce8537d384825e337e5903ff7367ddea798c52 CONTRIBUTING.md [info] Generating proof of possession... [info] [info] Challenge Response [info] ------------------ [info] [[&quot;153a0d4b1d228043992fec585cadb51974b053f7&quot;],&quot;ccee086dbc8a16b93b79912cb37f3b037bbf8269&quot;]The result of this operation can be used by the original renter to verify the the proof and confirm that the farmer still has possession of the file: &gt; $ storj verify-proof 9c8c37935f58d46e3301efe4f44724b8785a81a5 2 '[[&quot;153a0d4b1d228043992fec585cadb51974b053f7&quot;],&quot;ccee086dbc8a16b93b79912cb37f3b037bbf8269&quot;]' [info] [info] Expected: 9c8c37935f58d46e3301efe4f44724b8785a81a5 [info] Actual: 9c8c37935f58d46e3301efe4f44724b8785a81a5 [info] [info] The proof response is validFor more detailed usage information of the command line interface, run storj --help. × Search results Close "},"tutorial-contract-topics.html":{"id":"tutorial-contract-topics.html","title":"Tutorial: Publishing Storage Contracts","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Publishing Storage Contracts Nodes solicit storage contracts with the network by publishing information about their storage requirements as outlined in Protocol Specification. Storj implements a distributed publish/subscribe system based on an algorithm called Quasar. Quasar works by allowing nodes to advertise topics of interest to their neighbors and keeping a record of these topics in their neighborhood by storing them in an attenuated bloom filter. Each node has a view of the topics in which their neighbors are interested up to 3 hops away. By the nature of this design, the network forms gravity wells wherein messages of interest are efficiently relayed to nodes that are subscribed to the topic without flooding the network. This approach works well when there is a diverse number of topics. The Storj protocol leverages this by defining a matrix of criteria and descriptors in the form of opcodes representing the degree of which the criteria must be met. CriteriaAt the time of writing, there are 4 criteria column in the topic matrix: Size Duration Availability Speed SizeRefers to the size of the data to be stored. DurationRefers to the length of time for which the data should be stored. AvailabilityRefers to the relative uptime of required by the contract for retrieval of the stored data. SpeedRefers to the throughput desired for retrieval of the stored data. DescriptorsAt the time of writing, there are 3 descriptor opcodes representing low, medium, and high degrees of the criteria. Low: 0x01 Medium: 0x02 High: 0x03 The ranges represented by these descriptors are advisory and may change based on network performance and improvements to hardware over time. ------------------------------------------------------------------------------- | Descriptor | Size | Duration | Availability | Speed | |-----------------|-------------|------------|--------------|-----------------| | Low (`0x01`) | 0mb - 8mb | 0d - 30d | 0% - 50% | 0mbps - 6mbps | |-----------------|-------------|------------|--------------|-----------------| | Medium (`0x02`) | 8mb - 16mb | 30d - 90d | 50% - 80% | 6mbps - 12mbps | |-----------------|-------------|------------|--------------|-----------------| | High (`0x03`) | 16mb - 32mb | 90d - 270d | 80% - 99% | 12mbps - 32mbps | -------------------------------------------------------------------------------Topic FormatWhen publishing or subscribing to a given topic representing the degrees of these criteria, nodes must serialize the opcodes as the hex representation of the bytes in proper sequence. This sequence is defined as: prefix|size|duration|availability|speedThe first byte, &quot;prefix&quot;, is the static identifier for a contract publication. Contracts are not the only type of publication shared in the network, so the prefix acts as a namespace for a type of publication topic. The prefix for a contract publication is: 0x0f. To illustrate by example, we can determine the proper topic by analyzing the use case for a given file shard. For instance, if we want to store an asset that is displayed on a web page we can infer the following: The file is small The file may change often, so we should only store it for medium duration The file needs to always be available The file should be transferred quickly Using the matrix, we can determine the proper opcode sequence: [0x0f, 0x01, 0x02, 0x03, 0x03]Serialized as hex, our topic string becomes: 0f01020303Another example, by contrast, is data backup. Data backup is quite different than the previous example: The file is large (perhaps part of a hard drive backup) The file will not change and should be stored long term The file will not be accessed often, if ever The file does not need to be transferred at high speed Using the matrix, we can determine the proper opcode sequence: [0x0f, 0x03, 0x03, 0x01, 0x01]Serialized as hex, our topic string becomes: 0f03030101The resulting hex string from the serialized opcode byte sequence should be used as the topic parameter of a PUBLISH RPC as defined in the Protocol Specification. Nodes that are subscribed to the topic will receive the proposed storage contract and may begin contract negotiation with you directly. × Search results Close "},"tutorial-data-channels.html":{"id":"tutorial-data-channels.html","title":"Tutorial: Transferring File Shards","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Transferring File Shards Nodes on the Storj network implement a separate &quot;data channel&quot; for file transfer. Each node must expose a WebSocket server that accepts connections from clients who wish to use the channel for shard consignments and retrieval. The WebSocket server must be accessible at the same path as the JSON-RPC server and is negotiated by sending the Sec-WebSocket-Key header to indicate the connection upgrade as defined by RFC6455. Once the WebSocket connection is open, the client must send a JSON formatted message including the necessary information for the farmer to authorize the data channel. Authorizing a ChannelThe JSON message the client must provide to the farmer before establishing the channel must contain the token provided from a previous CONSIGN or RETRIEVE request, the hash of the data being transferred, and the operation (either PUSH or PULL). { &quot;token&quot;: &quot;5a7ac2dd58377085bad57f864b3a493c288b7c07&quot;, &quot;hash&quot;: &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;operation&quot;: &quot;PUSH&quot; } Authorization message frames must use opcode 0x1 (textual). The receiving farmer must check that she issued the received token within a reasonable amount of time (recommend 10 minutes) and that the supplied hash is associated with that token before sending or receiving any other data. If the authorization fails, the farmer must close the data channel, optionally responding with a status message. Status MessagesFarmers can communicate their status or the result of an operation by sending JSON formatted messages including code (HTTP status code) and message. { &quot;code&quot;: 200, &quot;message&quot;: &quot;Data consigned successfully&quot; }{ &quot;code&quot;: 401, &quot;message&quot;: &quot;Failed to authorize channel&quot; } Status message frames must use opcode 0x1 (textual). Consigning a ShardTo consign a shard (to upload the shard to a farmer), first send the appropriate authorization message. If the farmer does not respond with a failed status message, the channel is open and you can begin sending binary frames. Farmers must track the amount of data received and ensure that it does not exceed the amount defined in the contract. Once the farmer has received the number of bytes defined in the contract, she must verify the data against the hash defined in the contract. If these checks are successfully executed, then the farmer must respond with a positive status message and terminate the channel. Shard message frames must use opcode 0x2 (binary). Example (browser-based)var channel = new WebSocket('&lt;farmer_uri&gt;'); channel.addEventListener('open', function() { channel.send(JSON.stringify({ token: '&lt;token&gt;', hash: '&lt;hash&gt;', operation: 'PUSH' }); channel.send(new Blob([/* ... */])); }); channel.addEventListener('message', function(e) { var data = JSON.parse(e.data); if (data.code &amp;&amp; data.code !== 200) { console.error('Error consigning data:', data.message); } else { console.log('Successfully consigned data!'); } });Retrieving a ShardTo retrieve a shard from a farmer, first send the appropriate authorization message. The farmer will respond with a negative status message frame if you are not authorized and terminate the channel. If authorization is successful, you will immediately begin receiving binary message frames until there is no more data to be transferred - at which point the farmer must terminate the channel. Shard message frames must use opcode 0x2 (binary). Example (browser-based)var channel = new WebSocket('&lt;farmer_uri&gt;'); var fileparts = []; channel.addEventListener('open', function() { channel.send(JSON.stringify({ token: '&lt;token&gt;', hash: '&lt;hash&gt;', operation: 'PULL' }); }); channel.addEventListener('message', function(e) { fileparts.push(e.data); }); channel.addEventListener('close', function() { var file = new Blob(fileparts, { type: '&lt;mime_type&gt;' }); var url = URL.createObjectURL(file); location.href = url; });File ReconstructionIn most cases a complete file is consigned to a number of different farmers. To reconstruct a file, you'll need to know the location of each shard and the concatenation order. With this information, you can open data channels to each of the farmers storing the file's shards (with whatever degree of parallelism suits your needs) and concatenate the binary blobs received in the proper order. × Search results Close "},"tutorial-environment-variables.html":{"id":"tutorial-environment-variables.html","title":"Tutorial: Environment Variables","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Environment Variables Below is a list of environment variables that can be used to alter the behavior of the core library and associated tooling. STORJ_NETWORKThis value will be postfixed to your announced protocol version in the network. A value of testnet would advertise to the network you are running 0.7.0-testnet, which will isolate you to other nodes running the same exact version. See Running a Test Network for more information. STORJ_ALLOW_LOOPBACKBy default, the Network class will drop and ignore message from nodes who identify themeselves as a loopback interface like localhost, 127.0.0.1, etc. This is a security precaution to prevent others from causing you to send messages to yourself as well as prevent invalid contacts in your routing table. To disable this feature (primarily for local testing), set this variable to 1. STORJ_BRIDGEThis variable will change the default URI for the BridgeClient class. The default value is https://api.storj.io. If you run your own bridge, testing one locally, or otherwise would like to default to a different host, set this variable. This works well with the CLI (see Using the Command Line Tools) when testing against other bridges. × Search results Close "},"tutorial-private-testnet.html":{"id":"tutorial-private-testnet.html","title":"Tutorial: Running a Test Network","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Running a Test Network Setting up a private or partitioned version of the Storj network is very simple. The Storj protocol requires the inclusion of a protocol property nested inside the contact data included in every RPC message. See Protocol Specification for more information on the RPC message format. Protocol Identifier FormatNodes on the Storj network identify the version of the protocol they are running with the use of a semantic version tag. When a node is trying to determine whether or not another node is compatible with her version of the protocol, she checks the following: Is the MAJOR version the same? Is the MAJOR version 0? Is the MINOR version the same? If both nodes are running the same MAJOR version and that version is not 0, then the nodes are compatible. If the MAJOR version is 0, then the nodes are compatible only if the MINOR version is the same. For example: 0.5.1 is compatible with 0.5.3 0.5.1 is not compatible with 0.6.0 1.5.1 is compatible with 1.13.0 2.1.0 is not compatible with 1.13.0 Special IdentifiersThe semantic versions specification also allows for special identifiers by postfixing the version with a hyphen followed by some identifier. This is where the network partitioning magic happens. Let's say, for example, I work for &quot;Widgets Ltd&quot; and I want to deploy a Storj network within the Widgets Ltd private network. Every workstation would run a modified version of storj/farmer or maybe my own custom interface built atop storj/core. I would simply change my Storj-based software to use the version 1.5.0-widgetsltd. The Storj protocol sees this identifies as a strict match and therefore any nodes running this version of the software will only communicate with nodes running the exact protocol identifier. Changing the VersionChanging the version in storj/core is easy as pie. In your code, simply import the module and change the identifier like so: // Import core library var storj = require('storj'); // Modify protocol version storj.version.protocol = '1.5.0-widgetsltd'; // Get on with your stuff...If you are running &quot;vanilla&quot; Storj software, you can change the protocol version by setting the STORJ_NETWORK environment variable. This will add a postfix to the protocol version, which will partition the network to nodes that are running that exact version: STORJ_NETWORK=testnet storjshare --datadir /path/to/shardsThis concept applies broadly to deploying a custom Storj network for any purpose. This could be used for a public testnet (x.x.x-testnet) or for the private network example above. × Search results Close "},"tutorial-protocol-spec.html":{"id":"tutorial-protocol-spec.html","title":"Tutorial: Protocol Specification","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Protocol Specification Nodes communicate with each other using JSON-RPC 2.0 over HTTPS. This requires farmers (nodes who are contracted by renter to store data) to be publicly addressable and enables access to content from web browsers, mobile phones, and any other devices that speak HTTP (hint: everything). This document outlines the specification for the RPC interface by defining the message structure, required methods, and expected response formats that are needed for a Storj protocol compliant implementation. Request FormatRequests are formed according to the JSON-RPC 2.0 specification and are issued via HTTP POST. The Storj protocol requires the use of named parameters - positional parameters are not supported. Example: { &quot;method&quot;: &quot;PING&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;89cc3ddb4209c6e7e301c10c0257adf4fd85f253&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;3045022100de2e162d017a1e9d0ebfe2a94df3fc847b68281a9882...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The receiving node for this request would then respond with the result, which in the case of a PING message, is simply an acknowledgement that includes the recipient's contact information and required signature and nonce: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }In the event that an error occurs, an error property must be added to the response. You still need to include your contact data in the result property of the response: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;error&quot;: { &quot;code&quot;: -32603, &quot;message&quot;: &quot;OH GOD THERE'S SO MUCH BLOOD&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Joining the NetworkTo join the Storj network, one must only know the contact information for a single &quot;seed&quot; node. A node's contact information is defined as the following three properties: address - hostname, domain, or IP port - port number on which the node is listening nodeID - hash of the node's public key (see below) protocol - version of the protocol implementation This information can be expressed as a URI in the following format: storj://10.0.0.2:1337/89cc3ddb4209c6e7e301c10c0257adf4fd85f253In addition to knowing this information about the seed, you also will need to know this information about yourself, so that it can be provided to the nodes with which you are communicating. Your &quot;contact card&quot; must be provided as the contact parameter in every message sent (both requests and responses). This is because messages must be signed with your private key and your nodeID is used by recipients to verify two things: That you own the private key corresponding to your claimed nodeID That the message was in fact sent by you and not an attacker In the Storj network, nodes are identified by the hash of the public portion of an ECDSA key pair. Key pairs are generated using curve SECP256K1 and a node's nodeID is the &quot;pubkeyhash&quot;, defined as: RIPEMD160(SHA256(public_key))This pubkeyhash, combined with a message and signature is enough data to reconstruct the complete public key and is used in the Storj network to sign and verify messages. This ensures that nodes are unable to assume the identity of another node by claiming it has the same nodeID. PROBEBefore a node can join the network, it must determine whether or not it is reachable (or publicly addressable). This can be determined by sending a PROBE request to a known seed. { &quot;method&quot;: &quot;PROBE&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The PROBE RPC message triggers the recipient to attempt to reach the supplied Contact directly by sending a PING RPC message. If the target Contact reponds to the PING, then the PROBE should yield a success response, which is indicated by simply responding to the RPC message with only the required parameters and no error property. { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }If the PING message triggered by the PROBE fails, then the recipient of the PROBE RPC must respond with an error indicating to the sender that she is not addressable. { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;error&quot;: { &quot;code&quot;: -32603, &quot;message&quot;: &quot;PROBE FAILED&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }If the PROBE fails, you cannot successfully join the overlay and need to establish a tunnel through a node that is addressable on the network. FIND_TUNNELFinding a node that is willing to tunnel your connection to the overlay begins with a FIND_TUNNEL RPC message sent to a known seed. Nodes on the network maintain a record of known nodes that are willing to tunnel, by subscribing to &quot;tunnel announcements&quot; over the publish/subscribe system. For more information on how nodes announce willingness to tunnel, see the documentation for Tunnelling Connections. { &quot;method&quot;: &quot;FIND_TUNNEL&quot;, &quot;params&quot;: { &quot;relayers&quot;: [], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When a node receives a FIND_TUNNEL message, it should respond with ALPHA (3) contacts that are close the the sender's nodeID who have previously published their willingness to tunnel. If the recipient herself is willing to tunnel the connection, she may include herself in the response even if her nodeID is not closer to the sender's nodeID than her known tunnels. { &quot;result&quot;: { &quot;tunnels&quot;: [ { &quot;address&quot;: &quot;10.0.0.4&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, { &quot;address&quot;: &quot;10.0.0.5&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;68dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, { &quot;address&quot;: &quot;10.0.0.6&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;78dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; } ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The result of a FIND_TUNNEL message looks almost identical to the result of a FIND_NODE message, with the exception being the name of the result key is tunnels instead of nodes. Now that the original sender possesses the contact information for some known tunnels, she should keep them in her record so that she can later respond to other's FIND_TUNNEL requests appropriately. Before the node can join the overlay (after determining it is not publicly addressable), it needs to establish a connection tunnel through one of the Contacts received from the FIND_TUNNEL request. OPEN_TUNNELEstablishing a tunnel is initiated by sending an OPEN_TUNNEL RPC message to a node who has indicated their willingness to tunnel. Only the minimum required parameters need to be sent. In the future, the protocol may be enhanced to include additional information in the OPEN_TUNNEL RPC for negotiating payment channels or other conditions. { &quot;method&quot;: &quot;OPEN_TUNNEL&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The recipient of the OPEN_TUNNEL message must determine whether or not she can satisfy the request. This decision may be based upon an arbitrary limit set by the node regarding how many concurrent tunnels she wishes to open, available bandwidth, etc. If the node is capable of establishing the tunnel, she must do so, assigning a dedicated address or port to receive messages and data channel requests (see Transferring File Shards). Once the tunnel's dedicated entry point has been established, she responds to the sender of the OPEN_TUNNEL request with a unique WebSocket URI that includes a token, as well as an alias property which contains the contact information for the new entry point through which data will enter the tunnel. { &quot;result&quot;: { &quot;tunnel&quot;: &quot;ws://10.0.0.3:1337/tun?token=2bfb23f98e72&quot;, &quot;alias&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1338 }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }This response indicates that a tunnel has been established and the original sender can receive messages from the overlay by opening a WebSocket connection to the tunnel address in the reply. In addition, the sender must update it's Contact information to the included alias so that it can be reached by other peers in the overlay. If the recipient of the OPEN_TUNNEL message is not able to establish a tunnel for the sender, then she may respond with an error so that the sender can attempt to open a tunnel with other known contact. { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;error&quot;: { &quot;code&quot;: -32603, &quot;message&quot;: &quot;Failed to establish tunnel, multiplexer full&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Once your node has determined that it is publicly addressable on the network or has successfully established a tunnel, it can join the overlay network by issuing a FIND_NODE request sent to one or more known seeds. The request must include a key, contact (you), along with a signature and nonce. FIND_NODEWhen issuing a FIND_NODE request, you provide a key that represents the nodeID of the contact of which you would like to know their neighbors. When joining the network, this value is your own nodeID. { &quot;method&quot;: &quot;FIND_NODE&quot;, &quot;params&quot;: { &quot;key&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When a node receives a FIND_NODE RPC message, it must perform a lookup in it's routing table and respond with a nodes array containing the known contacts that are &quot;closest&quot; to the provided key. This is based on the XOR metric as the Storj network uses a Kademlia-based overlay. In addition, if the receiving node is not already aware of the requesting node, it may add the requester to it's own routing table to later inform other requesters. { &quot;result&quot;: { &quot;nodes&quot;: [ { &quot;address&quot;: &quot;10.0.0.4&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, { &quot;address&quot;: &quot;10.0.0.5&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;68dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, { &quot;address&quot;: &quot;10.0.0.6&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;78dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; } ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of the FIND_NODE response, the node attempting to join the network may iteratively send the same FIND_NODE request to contacts that have been newly added to the routing table to build out a wider view of the network. Once the joining node is satisfied with the size of the routing table (or there are no more nodes to discover), this is considered a successful join. Soliciting StorageOnce a node has a sufficiently complete routing table and view of the network, it's time to buddy up with it's neighbors to cooperate in the sharing and relay of publications. A &quot;publication&quot; is essentially a request for storage. When a node in the network wishes to store some data, it notifies it's closest neighbors who, if interested, will respond to negotiate a storage contract. If the neighbors are not offering storage or do not wish to fulfill the terms of the storage contract, they must check to see if any of their neighbors are and forward the publication to them. If no known neighbors are interested, then the publication is sent to a random node in that neighbor's routing table and the process repeats until an interested node fulfills the contract. SUBSCRIBEIn order to know what publications in which your neighbors are interested, we select the 3 nodes in our routing table that are identified by a nodeID that is closest to ours and we issue a SUBSCRIBE message to each of them: { &quot;method&quot;: &quot;SUBSCRIBE&quot;, &quot;params&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }To properly handle a SUBSCRIBE message, the recipient must respond with an attenuated bloom filter, with a size 160 bits and a depth of 3. This data structure represents 3 sets of topics to which the recipient's neighbors are subscribed 3 &quot;hops&quot; away. { &quot;result&quot;: { &quot;filters&quot;: [ &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }When the original requesting node receives this response, it must update it's local attenuated bloom filter to reflect this response, starting at it's filter at index 1 (since index 0 is reserved for topic to which the node itself is interested). UPDATEAfter the requester updates it's local view of it's neighbor's publication subscriptions, it must in turn update it's neighbors with it's own publication subscriptions by providing it's own attenuated bloom filter: { &quot;method&quot;: &quot;UPDATE&quot;, &quot;params&quot;: { &quot;filters&quot;: [ &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot;, &quot;0000000000000000000000000000000000000000&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }This method is essentially the &quot;push&quot; version of the SUBSCRIBE message, where instead of providing subscription information as a response, we provide it as a request. Whenever a node subscribes to a new publication topic, it should initiate another SUBSCRIBE/UPDATE loop with it's neighbors to ensure that it may cooperate in publication relay effectively. PUBLISHOnce a node has a view of the publications to which it's neighbors are subscribed, it is capable of issuing a PUBLISH message containing a topic and some content. This message is sent to the node's nearest neighbors, who then relay it to their neighbors based upon their own view of nearby subscriptions. The topic property and the corresponding contents data is arbitrary, but this mechanism is used for publishing &quot;asks&quot; for storage contracts. In this case, the topic is equal to the Contract type and the contents is equal to the proposed contract itself. See Publishing Storage Contracts for more information on how to choose a valid contract type for your storage needs. { &quot;method&quot;: &quot;PUBLISH&quot;, &quot;params&quot;: { &quot;uuid&quot;: &quot;7f0c40a2-e465-4f3e-b617-3d53460e34f7&quot;, &quot;topic&quot;: &quot;0f02010303&quot;, &quot;contents&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: null, &quot;farmer_id&quot;: null, &quot;farmer_signature&quot;: null, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: null }, &quot;publishers&quot;: [ &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; ], &quot;ttl&quot;: 1455228597837, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of a PUBLISH message, a node must first check to make sure it has not already received the publication. This is done by caching the uuid of received publications. If the node has already seen the publication, it should respond with an error message indicating such. The node should also make sure that the publication has not expired by checking the ttl against the current UNIX time. If the node has not previously seen the publication and the message has not expired, then it must check to see if the publication topic is of interest to itself by testing it's attenuated bloom filter at index 0 for the topic. If the node is interested in the publication, it may take action accordingly. In the case of storage contract, the node may begin communicating directly with the original publisher to finalize the contract. Regardless of whether or not the node is interested in the publication, it should acknowledge receipt of the publication to the forwarder: { &quot;result&quot;: { &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Then, it must append negative information to the publication message by adding it's own nodeID to the publishers property. Once the message has been updated with the negative information, the node must check it's attenuated bloom filter to see if any of it's neighbors are also interested and, if so, forward the message along to them. If no neighbors are interested, the node must select a random contact from the routing table and forward the message to that contact. Negotiating Storage ContractsWhen a node receives a contract proposal in the form of a PUBLISH message and that proposal meets the recipient's criteria, it can send an OFFER message to the original publisher. OFFERThe offer message must contain the original contract, supplemented with the information that is required of the offering node, which at minimum must include farmer_id, farmer_signature, and payment_destination. The *_signature property value should be the hex-encoded signature of the JSON string representation of the contract, minus both signature fields and with keys sorted alphanumerically. In addition to these fields, the offering node (or &quot;farmer&quot;) may modify the other fields in the contract to their liking if they wish to counter the original offer: { &quot;method&quot;: &quot;OFFER&quot;, &quot;params&quot;: { &quot;contract&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: null, &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }The receiving node must check the offer and determine whether or not the modified contract terms are satisfactory. If so, it may finalize the contract by adding it's signature to the renter_signature field: { &quot;result&quot;: { &quot;contract&quot;: { &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;, &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;renter_signature&quot;: &quot;304402202ccc152ee81fbff7e802c290cabea0c62384bb12...&quot;, &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;, &quot;data_size&quot;: 4906, &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;store_begin&quot;: 1455228907665, &quot;store_end&quot;: 2910457830468, &quot;audit_count&quot;: 10, &quot;payment_storage_price&quot;: 1200, &quot;payment_download_price&quot;: 2, &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot; }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Alternatively, the receiving node may counter the offer by modifying any of the fields and returning those in the response. The farmer must check the contract against it's signature to determine if the terms of the contract have been changed. This counter offer loop can continue until one party abandons the offer loop or until both parties have signed the same contract. Once a contract has been finalized, each node should store a copy locally that can be keyed by the data_hash. Executing a Storage ContractOnce a storage contract has been signed by both parties, the renter may execute the terms of the contract by issuing a CONSIGN message to the farmer. The purpose of this message is to deliver the data referenced by the contract for the farmer to store. The consign message must contain the hex-encoded data_shard itself, the contract_hash, as well as an audit_tree that contains the bottom leaves of the audit strategy's merkle tree (see Auditing a Storage Contract below). { &quot;method&quot;: &quot;CONSIGN&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;audit_tree&quot;: [ &quot;40a98e19c298631cba19d6c19691360ce08ccf36&quot;, &quot;02f0d971096305e797da9165cd50d4d1bb19590b&quot;, &quot;a44ad75d8aa118cdd73df77ae2543d3e87f94576&quot;, &quot;d84e8bfac28a98df418d0c3029f77a4d9f338e9e&quot;, &quot;7408bb5b0a9eefa56f3234fc83d2423f76c4b857&quot;, &quot;d1b71886c910d34b31cee9e23316abded9ef3fe0&quot;, &quot;0ac89686a12e26aaf952180c0fec5373224c4c1e&quot;, &quot;98c304116e7eb89839ff6c96202eb4c3cbdaf8e0&quot;, &quot;c7937b8a1be9da426e076eff70c5b4edf8a66270&quot;, &quot;c6c2c5cdafb99e4d62185d42e59522d15c33d676&quot;, &quot;1f87ca29e75944aa36e676b3ddf27e49a8ca4fe2&quot;, &quot;8585e356a517535b8a36ec9222b955c5b61a5227&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;, &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot; ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of a CONSIGN message, the farmer must lookup the reference contract by the supplied data_hash and verify that the renter is authorized to store the data and that the number of items in the audit_tree is equal to the next power of 2 of the audit_count supplied in the original contract. Once verified, the farmer must respond with a generated token that the renter can use to open a data channel with the farmer (via websocket) to deliver the data as a binary stream. For more information on the Data Channel specification see the tutorial for Transferring File Shards. In addition, the farmer should verify that the current UNIX time is greater than or equal to the agreed upon store_begin and less than the agreed upon store_end. If everything checks out, the farmer must store the consigned data in such a way that it may later be retrieved by it's hash. Once the farmer has done this, it must acknowledge the renter to confirm: { &quot;result&quot;: { &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Auditing a Storage ContractBefore a renter issues a CONSIGN RPC, it must pre-calculate a series of &quot;challenges&quot;, the number of which must equal the audit_count defined in the negotiated contract. A challenge is simply 32 random bytes encoded as hex. The generated challenges must not be shared until the renter wishes to issue an AUDIT request. When issuing a CONSIGN request, the renter must include an audit_tree which contains the bottom leaves of a merkle tree. Each of the bottom leaves of the tree must be equal to the double RIPEMD160(SHA256(challenge + shard)) encoded as hex. In order to ensure that the resulting merkle tree is properly &quot;balanced&quot;, the number of bottom leaves must be equal to the next power of 2 of the audit count. To ensure this, the additional leaves can simply be the double RIPEMD160(SHA256('')) (the same hash function for an audit, but applied to an empty buffer). To audit a farmer is to request proof that it is still honoring the terms of the storage contract without the need to have them supply the entire data_shard. To do this, the renter must supply the farmer with one of the secret pre-calculated challenges: { &quot;method&quot;: &quot;AUDIT&quot;, &quot;params&quot;: { &quot;audits&quot;: [ { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;challenge&quot;: &quot;6290bb9e1766bf3fc00eea3bb14146925611026d453e1aa95c32973f8baa5c98&quot; } ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Upon receipt of an AUDIT request, the farmer must lookup the data_shard by the supplied data_hash, then calculate the single RIPEMD160(SHA256(challenge + shard)). The result of this operation should hash again to match one of the items supplied in the audit_tree property of the original CONSIGN request. In addition to supplying this single-hashed value as proof that the farmer is still honoring the terms of the contract, the farmer must also provide the uncles required to rebuild the merkle tree. This proof response is specified as a series of nested JSON arrays: { &quot;result&quot;: { &quot;proofs&quot;: [ [[[ [[&quot;6a2f02144c461e178dc4496c263313e64d7a56ab&quot; ],&quot;efb0dfa48813e3289ba8d16e9e23cf1efa1a99fd&quot; ],&quot;dfb8877b84e7a7496a4b08b2aef6ffd02ccbfccc&quot; ],&quot;82c60f546bcaaabeb908c911b1fadb816e039409&quot; ],&quot;5e265b0256cd471c6af22bd66b59ed9242067654&quot;] ], &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }For clarification, given a simple merkle tree: +-- Hash_0 (Root) | +-- Hash_1 | | +-- Hash_3 | | +-- Hash_4 | +-- Hash_2 | | +-- Hash_5 | | +-- Hash_6 = RIPEMD160(SHA256(RIPEMD160(SHA256(challenge + shard))))The resulting format of a proof for an audit matching Hash_6 would appear as: [Hash_1, [Hash_5, [RIPEMD160(SHA256(challenge + shard))]]]And, the resulting format of a proof for an audit matching Hash_3 would appear as: [[[RIPEMD160(SHA256(challenge + shard))], Hash_5], Hash_2]Upon receipt of the farmer's proof, the renter must verify that the proof is valid by using it to rebuild the merkle tree. See Verification#verify for an implementation example. If the proof is verified successfully, then the renter is expected to issue a payment to the payment_destination defined in the original contract. The amount of the payment should be equal to: (payment_storage_price / audit_count) + (payment_download_price * downloads_since_last_audit)If the verification fails then the contract is null and no payment is required. Conversely, if the verification succeeds and the renter does not issue the payment in a timely manner, then the contract is also null and the farmer may decide to cease storage of the data. Downloading Consigned DataWhen a renter wishes to retrieve data that is stored under contract, it can issue a RETRIEVE RPC message that includes the data_hash to the farmer storing the data: { &quot;method&quot;: &quot;RETRIEVE&quot;, &quot;params&quot;: { &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }After the recipient of the RETRIEVE message verifies the sender's signature it must lookup the storage contract by the supplied data_hash and verify that the sender is the party with which the contract was negotiated. If all tests pass, then the farmer must respond with a generated token to allow the renter to open a data channel (via websocket) to retrieve the data as a binary stream. After the data shard is delivered successfully, the farmer must increment it's record of the downloads_since_last_audit (which must be reset after the next audit). For more information on the Data Channel specification see the tutorial for Transferring File Shards. { &quot;result&quot;: { &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.3.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }In addition, the renter must check the integrity of the returned data_shard by calculating the hash and checking it against the expected data_hash. If the test fails, then this effectively a failed audit and the contract is null. × Search results Close "},"tutorial-renting-data.html":{"id":"tutorial-renting-data.html","title":"Tutorial: Renting Data to the Network","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Renting Data to the Network This tutorial covers the process for using StorjCORE to rent data to farmers on the network programmatically using a number of tools included in the library. This walkthrough should also serve as an overview for a number of the tools included in the library and how they work together. BootstrappingBefore we can join the network, we need to set up a few required components: KeyPair - for representing our identity on the network StorageAdapter - for persisting our contracts and shard metadata Manager - for managing our persistence layer Start by importing the storj module and instantiating these objects: var storj = require('storj'); var keypair = new storj.KeyPair(); var persistence = new storj.LevelDBStorageAdapter('/path/to/datadir'); var manager = new storj.Manager(persistence);Now that we have a way of identifying ourselves to the network and keeping a record of our contracts, we can use the RenterInterface to join the network. var renter = new storj.RenterInterface({ keypair: keypair, manager: manager, address: 'ip.or.hostname', port: 1337 }); renter.join(function(err) { if (err) { return console.error('Failed to join the network'); } // CONTINUED IN NEXT EXAMPLE... });File PreparationNow that we have a connection to the network, we are ready to store some data. Before we can actually store the data, we need to get some information about the shards we need to store. We need to know: The hash of each shard that will be stored The size of each shard that will be stored The length of time we wish to store the data The number of audits we intend to issue over the life of the contract To get this information we need to process the file using a few more of the core components: FileDemuxer - for breaking the file into shards DataCipherKeyIv - for generating encryption key EncryptStream - for encrypting the shards Contract - for constructing the terms of the storage We will start by demultiplexing the file into several shard streams. Let's break our file into 6 shards. We will start by creating a FileDemuxer: var fs = require('fs'); var demuxer = new storj.FileDemuxer({ shards: 6, length: fs.statSync('/path/to/file').size });Now that we have prepared to shard a file, we need to set up event listeners on the demuxer for whenever a new shard stream is available. Once a shard stream is available, we need to encrypt it and calculate it's hash and size so we can create an appropriate Contract to offer the network. In addition we will write the encrypted shard to temporary storage so we don't have to process the file again when we are ready to transfer the data: var tmpdir = require('os').tmpdir(); var crypto = require('crypto'); var path = require('path'); demuxer.on('shard', function(shardStream) { var tmpName = path.join(tmpdir, crypto.randomBytes(6).toString('hex')); var tmpFile = fs.createWriteStream(tmpName); var key = new storj.DataCipherKeyIv('password', 'salt'); var encrypter = new storj.EncryptStream(key); var hasher = crypto.createHash('sha256'); var size = 0; encrypter.on('data', function(bytes) { hasher.update(bytes); size += bytes.length; }); tmpFile.on('finish', function() { // CONTINUED IN NEXT EXAMPLE... }); shardStream.pipe(encrypter).pipe(tmpFile); });Contract NegotiationWhen each shard is finished being encrypted and we know it's size and hash, it is time to create a Contract and offer it to the network. The example below is continued from inside the tmpFile.on('finish', callback) in the example above: var hash = utils.rmd160sha256(hasher.digest()); var contract = new storj.Contract({ renter_id: keypair.getNodeID(), data_size: size, data_hash: hash, store_begin: Date.now(), store_end: Date.now() + 604800000, // 7 days from now audit_count: 12 }); renter.getStorageOffer(contract, function(farmer, contract) { // CONTINUED IN NEXT EXAMPLE... });Now we have created a Contract for the shard and we are waiting for an offer from a farmer on the network. When we receive one, the callback supplied to RenterInterface#getStorageOffer above will trigger and we can proceed to transfer the shard to the farmer, but first we need to tell the farmer we are ready to transfer the shard to them and include the audit information they will need in the future. We will be using: AuditStream - for generating audit challenges and merkle tree StorageItem - for storing our private record of challenges Let's continue by reading the encrypted shard temporary file we just created and generating the challenges and merkle tree and saving a copy of the contract and associated challenges: var item = new storj.StorageItem({ hash: hash }); var auditGenerator = new storj.AuditStream(12); var encryptedShard = fs.createReadStream(tmpName); auditGenerator.on('finish', function() { item.addContract(farmer, contract); item.addAuditRecords(farmer, auditGenerator); manager.save(item, function(err) { if (err) { return console.error(err); } // CONTINUED IN NEXT EXAMPLE... }); }); encryptedShard.pipe(auditGenerator);Transferring ShardsNow that we have stored a copy of our contract and challenges, it's time to authorize a &quot;data channel&quot; (as described in Transferring File Shards) and transfer the shard to the farmer. We will be using: DataChannelClient - for opening the channel and transferring the data renter.getConsignToken(farmer, contract, auditGenerator, function(err, token) { if (err) { return console.error(err); } var client = new storj.DataChannelClient(farmer); var encryptedShard = fs.createReadStream(tmpName); client.on('open', function() { var datachannel = client.createWriteStream(token, hash); datachannel.on('finish', function() { // CONTINUED IN NEXT EXAMPLE }); encryptedShard.pipe(datachannel); }); });Remember that these operations for contract negotiation and shard transfer are taking place for each shard in the original file. You'll want to keep track of shards and their associated contracts by grouping references to them logically as the file that they compose. This is the responsibility of implementing clients. If you do not wish to manage this yourself, consider running a Bridge or using the Storj API. Auditing Farmer StorageNow that we have successfully consigned a shard, we will want to be sure that the farmer is being honest about storing it. We can verify this by requesting a proof using the challenges we generated previously. We will be using: Verification - for validating the farmer's challenge response var merkleRoot = auditGenerator.getPrivateRecord().root; var treeDepth = auditGenerator.getPrivateRecord().depth; renter.getStorageProof(farmer, item, function(err, proof) { if (err) { return console.error(err); } var verification = new storj.Verification(proof); var verifyResult = verification.verify(merkleRoot, treeDepth); if (verifyResult[0] !== verifyResult[1]) { return console.error('The proof is not valid'); } manager.save(item, function(err) { if (err) { return console.error(err); } // CONTINUED IN NEXT EXAMPLE }); });Retrieving ShardsNow that we have verified that the farmer is storing the shard, we know that we can later retrieve it when needed. The process for doing this is very similar to the process for storing the shard, only this time we'll be asking for a retrieval token and we will be receiving data over the data channel instead of sending. We'll also be using: DecryptStream - for decrypting the shard stream renter.getRetrieveToken(farmer, contract, function(err, token) { if (err) { return console.error(err); } var client = new storj.DataChannelClient(farmer); var decrypter = new storj.DecryptStream(keypair); var fileDestination = fs.createWriteStream('/path/to/download/shard'); client.on('open', function() { var download = client.createReadStream(token, hash); download.pipe(decrypter).pipe(fileDestination); }); fileDestination.on('finish', function() { console.info('Successfully downloaded shard!'); }); });This concludes the tutorial. To dive deeper, follow the reference links throughout this walkthrough and read the documentation on each of the classes used here. × Search results Close "},"tutorial-tunnel-connections.html":{"id":"tutorial-tunnel-connections.html","title":"Tutorial: Tunnelling Connections","body":" Storj Core Modules storjstorj/constantsstorj/utils Classes AuditStreamBridgeClientContactContractDataChannelClientDataChannelServerDataCipherKeyIvDecryptStreamEncryptStreamFarmerInterfaceFileDemuxerFileMuxerKeyPairKeyRingLevelDBFileStoreLevelDBStorageAdapterManagerNetworkPadderProofStreamProtocolRAMStorageAdapterRateLimiterRenterInterfaceStorageAdapterStorageItemStorageMigrationTransportTunnelClientTunnelDemuxerTunnelerInterfaceTunnelGatewayTunnelMuxerTunnelServerUnpadderVerification Events AuditStream#event:finishDecryptStream#event:dataDecryptStream#event:endEncryptStream#event:dataEncryptStream#event:endFarmerInterface#event:readyFileDemuxer#event:finishFileDemuxer#event:shardFileMuxer#event:drainManager#event:lockedManager#event:unlockedNetwork#event:readyRenterInterface#event:readyTunnelClient#event:closeTunnelClient#event:openTunnelerInterface#event:readyTunnelGateway#event:closeTunnelGateway#event:message/datachannelTunnelGateway#event:message/rpcTunnelGateway#event:openTunnelServer#event:lockedTunnelServer#event:readyTunnelServer#event:unlocked Tutorials Using the Command Line ToolsPublishing Storage ContractsTransferring File ShardsEnvironment VariablesRunning a Test NetworkProtocol SpecificationRenting Data to the NetworkTunnelling Connections Tunnelling Connections One of the most daunting problems to tackle when designing a stable and reliable distributed network is the traversal of various constraints such as NAT and firewalls. In some cases, software can use various strategies to &quot;punch out&quot; of these constraints and become publicly addressable on the Internet. The StorjCORE library makes use of these strategies, but when they fail we must devise more complex tactics for ensuring that network participants are reachable by their peers. The Storj protocol defines a series of RPC messages that can be exchanged in order to establish a &quot;tunnel&quot;. See the Protocol Specification for more detail on these RPC messages and their purposes. A tunnel is, in essence, a proxy that allows a client that is not exposed to the Internet to be addressable as if it were. This works by a private node opening a long-lived connection to a public node who establishes a dedicated means for accepting messages on behalf of the private node and &quot;pipes&quot; any data received via those means directly back to the private node over the previously established connection. Once a tunnel has been established, the private node can begin identifying herself to the network using her tunnel's address, instead of her own. Private nodes do not need to use the tunnel to contact other nodes on the network, but rather only to be contacted. Tunneling Diagram Announcing WillingnessWhen a node joins the network and is publicly addressable, it has the ability to announce to the network that it is willing and capable of tunneling connections on behalf on nodes who are private or unable to punch out to become addressable on the Internet. The process of doing this uses the same publish/subscribe system described in the Publishing Storage Contracts specification which enables nodes to maintain a view of subscriptions in their neighborhood of the network as described in the Protocol Specification. The difference between a contract publication and a tunnel announcement is in the opcode used for the topic and in the contents of the publication. Tunnel announcement publications use the opcode prefix 0x0e followed by a single criteria degree opcode to indicate their willingness to tunnel (0x00 to indicate &quot;I am no longer tunneling&quot; and 0x01 to indicate &quot;I am ready to tunnel&quot;). Whenever the condition changes, such as a node's maximum number of tunnels is reached or when a tunnel becomes available, it should issue a PUBLISH RPC message to it's nearest neighbors. { &quot;method&quot;: &quot;PUBLISH&quot;, &quot;params&quot;: { &quot;uuid&quot;: &quot;7f0c40a2-e465-4f3e-b617-3d53460e34f7&quot;, &quot;topic&quot;: &quot;0e01&quot;, &quot;contents&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337 }, &quot;publishers&quot;: [ &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot; ], &quot;ttl&quot;: 1455228597837, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.2&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Public nodes should subscribe to these topics so that they can maintain an up-to-date list of nodes who are capable and willing to tunnel connections, so they can respond accurately to FIND_TUNNEL messages from private nodes. Establishing a TunnelAfter a private node has discovered some willing tunnels using the FIND_TUNNEL RPC message defined in the Protocol Specification, it can now begin the handshake to establish the tunnel. This begins by sending the OPEN_TUNNEL RPC message to the desired tunneler node. The recipient of OPEN_TUNNEL will check: Do I have enough remaining tunnels? (based on arbitrary limit set by node) Am I already tunneling for this nodeID? Has a payment channel been opened? (future spec) If the tunneling node has enough tunnels, is not already tunneling the node, and (in a future spec) if a payment channel has been opened for bandwidth, then the tunneling node opens a new dedicated HTTP/WS server on an available port that will be used by the requester as it's &quot;contact&quot; information included in RPC messages. Before responding to the OPEN_TUNNEL RPC, the tunneler must also generate a unique authorization token that will be appended to the query string of it's tunnel entry point and provided back to the requester. { &quot;result&quot;: { &quot;tunnel&quot;: &quot;ws://10.0.0.3:1337/tun?token=2bfb23f98e72&quot;, &quot;alias&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1338 }, &quot;contact&quot;: { &quot;address&quot;: &quot;10.0.0.3&quot;, &quot;port&quot;: 1337, &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;, &quot;protocol&quot;: &quot;0.6.0&quot; }, &quot;nonce&quot;: 1455216323786, &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot; }, &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot; }Now the private node can connect to the tunnel URI provided and receive any messages sent to the alias contact information. Connecting to a TunnelOnce the OPEN_TUNNEL handshake is completed, the private node can establish a WebSocket connection to the tunneler, providing the token in the request's query string. Example (browser-based)var tunnel = new WebSocket('ws://10.0.0.3:1337/tun?token=2bfb23f98e72'); tunnel.addEventListener('open', function() { console.log('Tunnel established!'); }); tunnel.addEventListener('message', function(e) { console.log('Received tunneled message:', e.data); // Handle tunneled message here... });Handling Tunneled MessagesOnce the WebSocket tunnel has been opened and authorized, both the private node and the tunneling node have a bidirectional communication channel. RPC messages received by the tunnel to the dedicated entry point will be written to the tunnel and must be handled by the private node. RPC messages are sent with the WebSocket opcode 0x2 (binary) and must be parsed by the private node and then handled as if it were received directly. The binary chunk representing the RPC message must be prefixed with a special opcode (0x0c) indicating that it should be demuxed and handled as an RPC message. Once the tunneled message has been appropriately handled, the private node can instruct the tunnel to respond to the request by simply writing it's response message back to the tunnel using the same WebSocket opcode 0x2 (binary) with the appropriate 0x0c prefix. The tunneling node must parse the message and issue a response back to the originator of the message. Tunneled Shard TransferTransferring file shards through a tunnel is also carried out transparently from the perspective of the remote node. The remote node will negotiate a data channel via the appropriate RPC messages sent to the destination through the tunnel and use the resulting token and hash to open a data channel with the tunneler. The tunneler will use the existing WebSocket tunnel to it's private node to indicate the intent to establish a data channel by sending a special message called a &quot;signal&quot;. The SIGNAL message indicates to the private node's tunnel client that the tunnel server has established a data channel on it's behalf and will begin sending the received frames to the tunnel client. The SIGNAL message will simply include a unique identifier for the client to use for mux/demuxing subsequent frames in the case of multiple concurrent tunneled data channels. A SIGNAL message uses the WebSocket opcode 0x2 (binary), and prefixes the contained data with it's own opcode 0x0d. The prefix is followed by the WebSocket opcode sent by the originator to the tunnel server, which is followed by a quasi-unique 6 byte identifier assigned to the originator. For example, a tunnel client might receive a chunk of data that says &quot;hello world&quot; as part of a CONSIGN data channel: &lt;Buffer 0d 02 9d b4 a0 58 5f 31 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;In the above byte array, 0d indicates that this is a data channel signal, 02 indicates that the originator sent this data to the tunnel as binary, 9d b4 a0 58 5f 31 is the quasi-unique identifier for the originator so the client can demux the stream, and 68 65 6c 6c 6f 20 77 6f 72 6c 64 is the binary payload (in this case, &quot;hello world&quot;). When a tunnel client receives a SIGNAL message like this, it should check to see if it has already opened a local WebSocket connection to it's own data channel server. If it has not, it must open one using the quasi-unique identifier to track it, and writing any data in the signal to the socket using the WebSocket opcode included in the signal. The data channel server will also write back to the local WebSocket opened by the tunnel client, which is responsible for converting the data into the appropriate signal format and write the result back to the tunnel server. The tunnel server must then use the signal metadata to multiplex the streams out to their respective data channel originators. Reference TunnelClient TunnelServer TunnelMuxer TunnelDemuxer DataChannelClient DataChannelServer × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
