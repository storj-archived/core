<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>StorjCORE Tutorial: Protocol Specification</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.dark.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">StorjCORE</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-storj.html">storj</a></li><li><a href="module-storj_constants.html">storj/constants</a></li><li><a href="module-storj_utils.html">storj/utils</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Audit.html">Audit</a></li><li><a href="AuditStream.html">AuditStream</a></li><li><a href="Contact.html">Contact</a></li><li><a href="Contract.html">Contract</a></li><li><a href="DataChannelClient.html">DataChannelClient</a></li><li><a href="DataChannelServer.html">DataChannelServer</a></li><li><a href="DecryptStream.html">DecryptStream</a></li><li><a href="EncryptStream.html">EncryptStream</a></li><li><a href="FarmerInterface.html">FarmerInterface</a></li><li><a href="FileDemuxer.html">FileDemuxer</a></li><li><a href="FileMuxer.html">FileMuxer</a></li><li><a href="FSStorageAdapter.html">FSStorageAdapter</a></li><li><a href="KeyPair.html">KeyPair</a></li><li><a href="Manager.html">Manager</a></li><li><a href="Network.html">Network</a></li><li><a href="Proof.html">Proof</a></li><li><a href="Protocol.html">Protocol</a></li><li><a href="RAMStorageAdapter.html">RAMStorageAdapter</a></li><li><a href="RenterInterface.html">RenterInterface</a></li><li><a href="StorageAdapter.html">StorageAdapter</a></li><li><a href="StorageItem.html">StorageItem</a></li><li><a href="Transport.html">Transport</a></li><li><a href="TunnelClient.html">TunnelClient</a></li><li><a href="TunnelDemuxer.html">TunnelDemuxer</a></li><li><a href="TunnelGateway.html">TunnelGateway</a></li><li><a href="TunnelMuxer.html">TunnelMuxer</a></li><li><a href="TunnelServer.html">TunnelServer</a></li><li><a href="Verification.html">Verification</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="events.list.html" class="dropdown-toggle" data-toggle="dropdown">Events<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="AuditStream.html#event:finish">AuditStream#event:finish</a></li><li><a href="DecryptStream.html#event:data">DecryptStream#event:data</a></li><li><a href="DecryptStream.html#event:end">DecryptStream#event:end</a></li><li><a href="EncryptStream.html#event:data">EncryptStream#event:data</a></li><li><a href="EncryptStream.html#event:end">EncryptStream#event:end</a></li><li><a href="FarmerInterface.html#event:ready">FarmerInterface#event:ready</a></li><li><a href="FileDemuxer.html#event:shard">FileDemuxer#event:shard</a></li><li><a href="FileMuxer.html#event:drain">FileMuxer#event:drain</a></li><li><a href="Network.html#event:ready">Network#event:ready</a></li><li><a href="RenterInterface.html#event:ready">RenterInterface#event:ready</a></li><li><a href="TunnelClient.html#event:close">TunnelClient#event:close</a></li><li><a href="TunnelClient.html#event:open">TunnelClient#event:open</a></li><li><a href="TunnelGateway.html#event:close">TunnelGateway#event:close</a></li><li><a href="TunnelGateway.html#event:message/datachannel">TunnelGateway#event:message/datachannel</a></li><li><a href="TunnelGateway.html#event:message/rpc">TunnelGateway#event:message/rpc</a></li><li><a href="TunnelGateway.html#event:open">TunnelGateway#event:open</a></li><li><a href="TunnelServer.html#event:locked">TunnelServer#event:locked</a></li><li><a href="TunnelServer.html#event:unlocked">TunnelServer#event:unlocked</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="tutorials.list.html" class="dropdown-toggle" data-toggle="dropdown">Tutorials<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="tutorial-contract-topics.html">Publishing Storage Contracts</a></li><li><a href="tutorial-data-channels.html">Transferring File Shards</a></li><li><a href="tutorial-private-testnet.html">Running a Test Network</a></li><li><a href="tutorial-protocol-spec.html">Protocol Specification</a></li><li><a href="tutorial-renting-data.html">Renting Data to the Network</a></li><li><a href="tutorial-tunnel-connections.html">Tunnelling Connections</a></li>
				</ul>
			</li>
			
		</ul>
		<div class="col-sm-3 col-md-3">
            <form class="navbar-form" role="search">
                <div class="input-group">
                    <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                    <div class="input-group-btn">
                        <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                    </div>
                </div>
            </form>
        </div>
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			<section class="tutorial-section">

<header>
    

    <h2>Protocol Specification</h2>
</header>

<article>
    <p>Nodes communicate with each other using
<a href="http://www.jsonrpc.org/specification">JSON-RPC 2.0</a> over HTTPS. This requires
farmers (nodes who are contracted by renter to store data) to be publicly
addressable and enables access to content from web browsers, mobile phones, and
any other devices that speak HTTP (hint: everything).</p>
<p>This document outlines the specification for the RPC interface by defining the
message structure, required methods, and expected response formats that are
needed for a Storj protocol compliant implementation.</p>
<h3>Request Format</h3><p>Requests are formed according to the JSON-RPC 2.0 specification and are issued
via HTTP POST. The Storj protocol requires the use of <em>named parameters</em> -
positional parameters are not supported. Example:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;PING&quot;,
  &quot;params&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;89cc3ddb4209c6e7e301c10c0257adf4fd85f253&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;3045022100de2e162d017a1e9d0ebfe2a94df3fc847b68281a9882...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>The receiving node for this request would then respond with the result, which
in the case of a <code>PING</code> message, is simply an acknowledgement that includes
the recipient's contact information and required <code>signature</code> and <code>nonce</code>:</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>In the event that an error occurs, an <code>error</code> property must be <em>added</em> to the
response. You <em>still</em> need to include your <code>contact</code> data in the <code>result</code>
property of the response:</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;error&quot;: {
    &quot;code&quot;: -32603,
    &quot;message&quot;: &quot;OH GOD THERE'S SO MUCH BLOOD&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><h3>Joining the Network</h3><p>To join the Storj network, one must only know the contact information for a
single &quot;seed&quot; node. A node's contact information is defined as the following
three properties:</p>
<ul>
<li><code>address</code> - hostname, domain, or IP</li>
<li><code>port</code> - port number on which the node is listening</li>
<li><code>nodeID</code> - hash of the node's public key (see below)</li>
<li><code>protocol</code> - version of the protocol implementation</li>
</ul>
<p>This information can be expressed as a URI in the following format:</p>
<pre class="prettyprint source"><code>storj://10.0.0.2:1337/89cc3ddb4209c6e7e301c10c0257adf4fd85f253</code></pre><p>In addition to knowing this information about the seed, you also will need to
know this information about yourself, so that it can be provided to the nodes
with which you are communicating. Your &quot;contact card&quot; must be provided as the
<code>contact</code> parameter in every message sent (both requests and responses). This
is because messages must be signed with your private key and your <code>nodeID</code> is
used by recipients to verify two things:</p>
<ol>
<li>That you own the private key corresponding to your claimed <code>nodeID</code></li>
<li>That the message was in fact sent by you and not an attacker</li>
</ol>
<p>In the Storj network, nodes are identified by the hash of the public portion of
an ECDSA key pair. Key pairs are generated using curve SECP256K1 and a node's
<code>nodeID</code> is the &quot;pubkeyhash&quot;, defined as:</p>
<pre class="prettyprint source"><code>RIPEMD160(SHA256(public_key))</code></pre><p>This pubkeyhash, combined with a message and signature is enough data to
reconstruct the complete public key and is used in the Storj network to sign
and verify messages. This ensures that nodes are unable to assume the identity
of another node by claiming it has the same <code>nodeID</code>.</p>
<h4>PROBE</h4><p>Before a node can join the network, it must determine whether or not it is
reachable (or <em>publicly addressable</em>). This can be determined by sending a
<code>PROBE</code> request to a known seed.</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;PROBE&quot;,
  &quot;params&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.6.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>The <code>PROBE</code> RPC message triggers the recipient to attempt to reach the
supplied <a href="Contact.html">Contact</a> directly by sending a <code>PING</code> RPC message. If the
target <a href="Contact.html">Contact</a> reponds to the <code>PING</code>, then the <code>PROBE</code> should yield
a success response, which is indicated by simply responding to the RPC
message with only the required parameters and <strong>no</strong> <code>error</code> property.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.6.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>If the <code>PING</code> message triggered by the <code>PROBE</code> fails, then the recipient of the
<code>PROBE</code> RPC must respond with an error indicating to the sender that she is not
addressable.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.6.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;error&quot;: {
    &quot;code&quot;: -32603,
    &quot;message&quot;: &quot;PROBE FAILED&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>If the <code>PROBE</code> fails, you cannot successfully join the overlay and need to
establish a <strong>tunnel</strong> through a node that <em>is</em> addressable on the network.</p>
<h4>FIND_TUNNEL</h4><p>Finding a node that is willing to tunnel your connection to the overlay begins
with a <code>FIND_TUNNEL</code> RPC message sent to a known seed. Nodes on the network
maintain a record of known nodes that are willing to tunnel, by subscribing to
&quot;tunnel announcements&quot; over the publish/subscribe system.</p>
<blockquote>
<p>For more information on how nodes announce willingness to tunnel, see the
documentation for <a href="tutorial-tunnel-connections.html">Tunnelling Connections</a>.</p>
</blockquote>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;FIND_TUNNEL&quot;,
  &quot;params&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>When a node receives a <code>FIND_TUNNEL</code> message, it should respond with <code>ALPHA</code>
(3) contacts that are close the the sender's <code>nodeID</code> who have previously
published their willingness to tunnel. If the recipient herself is willing to
tunnel the connection, she may include herself in the response even if her
<code>nodeID</code> is not closer to the sender's <code>nodeID</code> than her known tunnels.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;tunnels&quot;: [
      {
        &quot;address&quot;: &quot;10.0.0.4&quot;,
        &quot;port&quot;: 1337,
        &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
        &quot;protocol&quot;: &quot;0.6.0&quot;
      },
      {
        &quot;address&quot;: &quot;10.0.0.5&quot;,
        &quot;port&quot;: 1337,
        &quot;nodeID&quot;: &quot;68dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
        &quot;protocol&quot;: &quot;0.6.0&quot;
      },
      {
        &quot;address&quot;: &quot;10.0.0.6&quot;,
        &quot;port&quot;: 1337,
        &quot;nodeID&quot;: &quot;78dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
        &quot;protocol&quot;: &quot;0.6.0&quot;
      }
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.6.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>The result of a <code>FIND_TUNNEL</code> message looks almost identical to the result of a
<code>FIND_NODE</code> message, with the exception being the name of the result key is
<code>tunnels</code> instead of <code>nodes</code>. Now that the original sender possesses the
contact information for some known tunnels, she should keep them in her record
so that she can later respond to other's <code>FIND_TUNNEL</code> requests appropriately.</p>
<p>Before the node can join the overlay (after determining it is not publicly
addressable), it needs to establish a connection tunnel through one of the
<a href="Contact.html">Contact</a>s received from the <code>FIND_TUNNEL</code> request.</p>
<h4>OPEN_TUNNEL</h4><p>Establishing a tunnel is initiated by sending an <code>OPEN_TUNNEL</code> RPC message to a
node who has indicated their willingness to tunnel. Only the minimum required
parameters need to be sent.</p>
<blockquote>
<p>In the future, the protocol may be enhanced to include additional information
in the <code>OPEN_TUNNEL</code> RPC for negotiating payment channels or other conditions.</p>
</blockquote>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;OPEN_TUNNEL&quot;,
  &quot;params&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.6.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>The recipient of the <code>OPEN_TUNNEL</code> message must determine whether or not she
can satisfy the request. This decision may be based upon an arbitrary limit
set by the node regarding how many concurrent tunnels she wishes to open,
available bandwidth, etc. If the node is capable of establishing the tunnel,
she must do so, assigning a dedicated address or port to receive messages and
data channel requests (see <a href="tutorial-data-channels.html">Transferring File Shards</a>).</p>
<p>Once the tunnel's dedicated entry point has been established, she responds to
the sender of the <code>OPEN_TUNNEL</code> request with a unique WebSocket URI that
includes a token, as well as an <code>alias</code> property which contains the contact
information for the new entry point through which data will enter the tunnel.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;tunnel&quot;: &quot;ws://10.0.0.3:1337/tun?token=2bfb23f98e72&quot;,
    &quot;alias&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1338
    },
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.6.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>This response indicates that a tunnel has been established and the original
sender can receive messages from the overlay by opening a WebSocket connection
to the <code>tunnel</code> address in the reply. In addition, the sender must update it's
<a href="Contact.html">Contact</a> information to the included <code>alias</code> so that it can be reached
by other peers in the overlay.</p>
<p>If the recipient of the <code>OPEN_TUNNEL</code> message is not able to establish a tunnel
for the sender, then she may respond with an error so that the sender can
attempt to open a tunnel with other known contact.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.6.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;error&quot;: {
    &quot;code&quot;: -32603,
    &quot;message&quot;: &quot;Failed to establish tunnel, multiplexer full&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>Once your node has determined that it is publicly addressable on the network
or has successfully established a tunnel, it can join the overlay network by
issuing a <code>FIND_NODE</code> request sent to one or more known seeds. The request must
include a <code>key</code>, <code>contact</code> (you), along with a <code>signature</code> and <code>nonce</code>.</p>
<h4>FIND_NODE</h4><p>When issuing a <code>FIND_NODE</code> request, you provide a <code>key</code> that represents the
<code>nodeID</code> of the contact of which you would like to know their neighbors. When
joining the network, this value is <em>your own <code>nodeID</code></em>.</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;FIND_NODE&quot;,
  &quot;params&quot;: {
    &quot;key&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>When a node receives a <code>FIND_NODE</code> RPC message, it must perform a lookup in
it's routing table and respond with a <code>nodes</code> array containing the known
contacts that are &quot;closest&quot; to the provided key. This is based on the XOR
metric as the Storj network uses a
<a href="https://en.wikipedia.org/wiki/Kademlia">Kademlia</a>-based overlay. In addition,
if the receiving node is not already aware of the requesting node, it may add
the requester to it's own routing table to later inform other requesters.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;nodes&quot;: [
      {
        &quot;address&quot;: &quot;10.0.0.4&quot;,
        &quot;port&quot;: 1337,
        &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
        &quot;protocol&quot;: &quot;0.3.0&quot;
      },
      {
        &quot;address&quot;: &quot;10.0.0.5&quot;,
        &quot;port&quot;: 1337,
        &quot;nodeID&quot;: &quot;68dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
        &quot;protocol&quot;: &quot;0.3.0&quot;
      },
      {
        &quot;address&quot;: &quot;10.0.0.6&quot;,
        &quot;port&quot;: 1337,
        &quot;nodeID&quot;: &quot;78dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
        &quot;protocol&quot;: &quot;0.3.0&quot;
      }
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>Upon receipt of the <code>FIND_NODE</code> response, the node attempting to join the
network may iteratively send the same <code>FIND_NODE</code> request to contacts that have
been newly added to the routing table to build out a wider view of the network.
Once the joining node is satisfied with the size of the routing table (or there
are no more nodes to discover), this is considered a successful join.</p>
<h3>Soliciting Storage</h3><p>Once a node has a sufficiently complete routing table and view of the network,
it's time to buddy up with it's neighbors to cooperate in the sharing and relay
of publications. A &quot;publication&quot; is essentially a <strong>request for storage</strong>. When
a node in the network wishes to store some data, it notifies it's closest
neighbors who, if interested, will respond to negotiate a storage contract.</p>
<p>If the neighbors are not offering storage or do not wish to fulfill the terms of
the storage contract, they must check to see if any of their neighbors are and
forward the publication to them. If no known neighbors are interested, then the
publication is sent to a random node in that neighbor's routing table and the
process repeats until an interested node fulfills the contract.</p>
<h4>SUBSCRIBE</h4><p>In order to know what publications in which your neighbors are interested, we
select the 3 nodes in our routing table that are identified by a <code>nodeID</code> that
is closest to ours and we issue a <code>SUBSCRIBE</code> message to each of them:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;SUBSCRIBE&quot;,
  &quot;params&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>To properly handle a <code>SUBSCRIBE</code> message, the recipient must respond with an
<em>attenuated bloom filter</em>, with a size 160 bits and a depth of 3. This data
structure represents 3 sets of topics to which the recipient's neighbors are
subscribed 3 &quot;hops&quot; away.</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;filters&quot;: [
      &quot;0000000000000000000000000000000000000000&quot;,
      &quot;0000000000000000000000000000000000000000&quot;,
      &quot;0000000000000000000000000000000000000000&quot;
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.3&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>When the original requesting node receives this response, it must update it's
local attenuated bloom filter to reflect this response, starting at it's filter
at index <code>1</code> (since index <code>0</code> is reserved for topic to which the node itself is
interested).</p>
<h4>UPDATE</h4><p>After the requester updates it's local view of it's neighbor's publication
subscriptions, it must in turn update it's neighbors with it's own publication
subscriptions by providing it's own attenuated bloom filter:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;UPDATE&quot;,
  &quot;params&quot;: {
    &quot;filters&quot;: [
      &quot;0000000000000000000000000000000000000000&quot;,
      &quot;0000000000000000000000000000000000000000&quot;,
      &quot;0000000000000000000000000000000000000000&quot;
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>This method is essentially the &quot;push&quot; version of the <code>SUBSCRIBE</code> message, where
instead of providing subscription information as a response, we provide it as a
request. Whenever a node subscribes to a new publication topic, it should
initiate another <code>SUBSCRIBE</code>/<code>UPDATE</code> loop with it's neighbors to ensure that
it may cooperate in publication relay effectively.</p>
<h4>PUBLISH</h4><p>Once a node has a view of the publications to which it's neighbors are
subscribed, it is capable of issuing a <code>PUBLISH</code> message containing a <code>topic</code>
and some <code>content</code>. This message is sent to the node's nearest neighbors, who
then relay it to their neighbors based upon their own view of nearby
subscriptions.</p>
<p>The <code>topic</code> property and the corresponding <code>contents</code> data is arbitrary, but
this mechanism is used for publishing &quot;asks&quot; for storage contracts. In this
case, the <code>topic</code> is equal to the <a href="Contract.html">Contract</a> type and the <code>contents</code> is
equal to the proposed contract itself. See <a href="tutorial-contract-topics.html">Publishing Storage Contracts</a> for more
information on how to choose a valid contract type for your storage needs.</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;PUBLISH&quot;,
  &quot;params&quot;: {
    &quot;uuid&quot;: &quot;7f0c40a2-e465-4f3e-b617-3d53460e34f7&quot;,
    &quot;topic&quot;: &quot;0f02010303&quot;,
    &quot;contents&quot;: {
      &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;,
      &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;renter_signature&quot;: null,
      &quot;farmer_id&quot;: null,
      &quot;farmer_signature&quot;: null,
      &quot;data_size&quot;: 4906,
      &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
      &quot;store_begin&quot;: 1455228907665,
      &quot;store_end&quot;: 2910457830468,
      &quot;audit_count&quot;: 10,
      &quot;payment_storage_price&quot;: 1200,
      &quot;payment_download_price&quot;: 2,
      &quot;payment_destination&quot;: null
    },
    &quot;publishers&quot;: [
      &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;
    ],
    &quot;ttl&quot;: 1455228597837,
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>Upon receipt of a <code>PUBLISH</code> message, a node must first check to make sure it
has not already received the publication. This is done by caching the <code>uuid</code> of
received publications. If the node has already seen the publication, it should
respond with an error message indicating such. The node should also make sure
that the publication has not expired by checking the <code>ttl</code> against the current
UNIX time.</p>
<p>If the node has not previously seen the publication and the message has not
expired, then it must check to see if the publication topic is of interest to
itself by testing it's attenuated bloom filter at index <code>0</code> for the topic. If
the node is interested in the publication, it may take action accordingly. In
the case of storage contract, the node may begin communicating directly with
the original publisher to finalize the contract.</p>
<p>Regardless of whether or not the node is interested in the publication, it
should acknowledge receipt of the publication to the forwarder:</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>Then, it must append <em>negative information</em> to the publication message by
adding it's own <code>nodeID</code> to the <code>publishers</code> property. Once the message has
been updated with the negative information, the node must check it's attenuated
bloom filter to see if any of it's neighbors are also interested and, if so,
forward the message along to them. If no neighbors are interested, the node
must select a random contact from the routing table and forward the message to
that contact.</p>
<h3>Negotiating Storage Contracts</h3><p>When a node receives a contract proposal in the form of a <code>PUBLISH</code> message and
that proposal meets the recipient's criteria, it can send an <code>OFFER</code> message to
the original publisher.</p>
<h4>OFFER</h4><p>The offer message must contain the original contract, supplemented with the
information that is required of the offering node, which at minimum must
include <code>farmer_id</code>, <code>farmer_signature</code>, and <code>payment_destination</code>.</p>
<blockquote>
<p>The <code>*_signature</code> property value should be the hex-encoded signature of the
JSON string representation of the contract, minus both signature fields and
with keys sorted alphanumerically.</p>
</blockquote>
<p>In addition to these fields, the offering node (or &quot;farmer&quot;) may modify the
other fields in the contract to their liking if they wish to counter the
original offer:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;OFFER&quot;,
  &quot;params&quot;: {
    &quot;contract&quot;: {
      &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;,
      &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;renter_signature&quot;: null,
      &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;,
      &quot;data_size&quot;: 4906,
      &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
      &quot;store_begin&quot;: 1455228907665,
      &quot;store_end&quot;: 2910457830468,
      &quot;audit_count&quot;: 10,
      &quot;payment_storage_price&quot;: 1200,
      &quot;payment_download_price&quot;: 2,
      &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot;
    },
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>The receiving node must check the offer and determine whether or not the
modified contract terms are satisfactory. If so, it may finalize the contract
by adding it's signature to the <code>renter_signature</code> field:</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;contract&quot;: {
      &quot;type&quot;: &quot;56ce3e837f575827cb5a94e2b609756a48fa4a3882f5e762b262af31f432878d&quot;,
      &quot;renter_id&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;renter_signature&quot;: &quot;304402202ccc152ee81fbff7e802c290cabea0c62384bb12...&quot;,
      &quot;farmer_id&quot;: &quot;58dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;farmer_signature&quot;: &quot;304502203f2be986f4213c45bf2f78c57cbf4001b049c4fd...&quot;,
      &quot;data_size&quot;: 4906,
      &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
      &quot;store_begin&quot;: 1455228907665,
      &quot;store_end&quot;: 2910457830468,
      &quot;audit_count&quot;: 10,
      &quot;payment_storage_price&quot;: 1200,
      &quot;payment_download_price&quot;: 2,
      &quot;payment_destination&quot;: &quot;1JUhMAZj2Mkb4mRaGxbBYPsStryPyDxPuj&quot;
    },
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>Alternatively, the receiving node may counter the offer by modifying any of the
fields and returning those in the response. The farmer must check the contract
against it's signature to determine if the terms of the contract have been
changed. This counter offer loop can continue until one party abandons the
offer loop or until both parties have signed the same contract.</p>
<blockquote>
<p>Once a contract has been finalized, each node should store a copy locally
that can be keyed by the <code>data_hash</code>.</p>
</blockquote>
<h3>Executing a Storage Contract</h3><p>Once a storage contract has been signed by both parties, the renter may execute
the terms of the contract by issuing a <code>CONSIGN</code> message to the farmer. The
purpose of this message is to deliver the data referenced by the contract for
the farmer to store. The consign message must contain the hex-encoded
<code>data_shard</code> itself, the <code>contract_hash</code>, as well as an <code>audit_tree</code> that
contains the bottom leaves of the audit strategy's merkle tree (see <strong>Auditing
a Storage Contract</strong> below).</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;CONSIGN&quot;,
  &quot;params&quot;: {
    &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
    &quot;audit_tree&quot;: [
      &quot;40a98e19c298631cba19d6c19691360ce08ccf36&quot;,
      &quot;02f0d971096305e797da9165cd50d4d1bb19590b&quot;,
      &quot;a44ad75d8aa118cdd73df77ae2543d3e87f94576&quot;,
      &quot;d84e8bfac28a98df418d0c3029f77a4d9f338e9e&quot;,
      &quot;7408bb5b0a9eefa56f3234fc83d2423f76c4b857&quot;,
      &quot;d1b71886c910d34b31cee9e23316abded9ef3fe0&quot;,
      &quot;0ac89686a12e26aaf952180c0fec5373224c4c1e&quot;,
      &quot;98c304116e7eb89839ff6c96202eb4c3cbdaf8e0&quot;,
      &quot;c7937b8a1be9da426e076eff70c5b4edf8a66270&quot;,
      &quot;c6c2c5cdafb99e4d62185d42e59522d15c33d676&quot;,
      &quot;1f87ca29e75944aa36e676b3ddf27e49a8ca4fe2&quot;,
      &quot;8585e356a517535b8a36ec9222b955c5b61a5227&quot;,
      &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;,
      &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;,
      &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;,
      &quot;ba084d3f143f2896809d3f1d7dffed472b39d8de&quot;
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>Upon receipt of a <code>CONSIGN</code> message, the farmer must lookup the reference
contract by the supplied <code>data_hash</code> and verify that the renter is authorized
to store the data and that the number of items in the <code>audit_tree</code> is equal to
the next power of 2 of the <code>audit_count</code> supplied in the original contract.</p>
<p>Once verified, the farmer must respond with a generated token that the renter
can use to open a data channel with the farmer (via websocket) to deliver the
data as a binary stream.</p>
<blockquote>
<p>For more information on the Data Channel specification see the tutorial for
<a href="tutorial-data-channels.html">Transferring File Shards</a>.</p>
</blockquote>
<p>In addition, the farmer should verify that the current UNIX time is greater
than or equal to the agreed upon <code>store_begin</code> and less than the agreed upon
<code>store_end</code>. If everything checks out, the farmer must store the consigned data
in such a way that it may later be retrieved by it's hash. Once the farmer has
done this, it must acknowledge the renter to confirm:</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;,
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><h3>Auditing a Storage Contract</h3><p>Before a renter issues a <code>CONSIGN</code> RPC, it must pre-calculate a series of
&quot;challenges&quot;, the number of which must equal the <code>audit_count</code> defined in the
negotiated contract. A challenge is simply 32 random bytes encoded as hex. The
generated challenges must not be shared until the renter wishes to issue an
<code>AUDIT</code> request.</p>
<p>When issuing a <code>CONSIGN</code> request, the renter must include an <code>audit_tree</code> which
contains the bottom leaves of a merkle tree. Each of the bottom leaves of the
tree must be equal to the double <code>RIPEMD160(SHA256(challenge + shard))</code> encoded
as hex. In order to ensure that the resulting merkle tree is properly
&quot;balanced&quot;, the number of bottom leaves must be equal to the next power of 2 of
the audit count. To ensure this, the additional leaves can simply be the double
<code>RIPEMD160(SHA256(''))</code> (the same hash function for an audit, but applied to an
empty buffer).</p>
<p>To audit a farmer is to request proof that it is still honoring the terms of
the storage contract without the need to have them supply the entire
<code>data_shard</code>. To do this, the renter must supply the farmer with one of the
secret pre-calculated challenges:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;AUDIT&quot;,
  &quot;params&quot;: {
    &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
    &quot;challenge&quot;: &quot;6290bb9e1766bf3fc00eea3bb14146925611026d453e1aa95c32973f8baa5c98&quot;,
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>Upon receipt of an <code>AUDIT</code> request, the farmer must lookup the <code>data_shard</code> by
the supplied <code>data_hash</code>, then calculate the <em>single</em>
<code>RIPEMD160(SHA256(challenge + shard))</code>.</p>
<blockquote>
<p>The result of this operation should hash again to match one of the items
supplied in the <code>audit_tree</code> property of the original <code>CONSIGN</code> request.</p>
</blockquote>
<p>In addition to supplying this single-hashed value as proof that the farmer is still honoring
the terms of the contract, the farmer must <em>also</em> provide the uncles required
to rebuild the merkle tree. This <strong>proof</strong> response is specified as a series
of nested JSON arrays:</p>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;proof&quot;: [
      [
        [
          [
            [
              &quot;6a2f02144c461e178dc4496c263313e64d7a56ab&quot;
            ],
            &quot;efb0dfa48813e3289ba8d16e9e23cf1efa1a99fd&quot;
          ],
          &quot;dfb8877b84e7a7496a4b08b2aef6ffd02ccbfccc&quot;
        ],
        &quot;82c60f546bcaaabeb908c911b1fadb816e039409&quot;
      ],
      &quot;5e265b0256cd471c6af22bd66b59ed9242067654&quot;
    ],
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>For clarification, given a simple merkle tree:</p>
<pre class="prettyprint source"><code>+-- Hash_0 (Root)
|   +-- Hash_1
|   |   +-- Hash_3
|   |   +-- Hash_4
|   +-- Hash_2
|   |   +-- Hash_5
|   |   +-- Hash_6 = RIPEMD160(SHA256(RIPEMD160(SHA256(challenge + shard))))</code></pre><p>The resulting format of a proof for an audit matching Hash_6 would appear as:</p>
<pre class="prettyprint source"><code>[Hash_1, [Hash_5, [RIPEMD160(SHA256(challenge + shard))]]]</code></pre><p>And, the resulting format of a proof for an audit matching Hash_3 would appear as:</p>
<pre class="prettyprint source"><code>[[[RIPEMD160(SHA256(challenge + shard))], Hash_5], Hash_2]</code></pre><p>Upon receipt of the farmer's proof, the renter must verify that the proof is
valid by using it to rebuild the merkle tree. See <a href="Verification.html#verify">Verification#verify</a>
for an implementation example. If the proof is verified successfully, then the
renter is expected to issue a payment to the <code>payment_destination</code> defined in
the original contract. The amount of the payment should be equal to:</p>
<pre class="prettyprint source"><code>(payment_storage_price / audit_count) + (payment_download_price * downloads_since_last_audit)</code></pre><p>If the verification fails then the contract is null and no payment is required.
Conversely, if the verification succeeds and the renter does not issue the
payment in a timely manner, then the contract is also null and the farmer may
decide to cease storage of the data.</p>
<h3>Downloading Consigned Data</h3><p>When a renter wishes to retrieve data that is stored under contract, it can
issue a <code>RETRIEVE</code> RPC message that includes the <code>data_hash</code> to the farmer
storing the data:</p>
<pre class="prettyprint source"><code>{
  &quot;method&quot;: &quot;RETRIEVE&quot;,
  &quot;params&quot;: {
    &quot;data_hash&quot;: &quot;4efc1c36d3349189fb3486d2914f56e05d3e66f8&quot;,
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>After the recipient of the <code>RETRIEVE</code> message verifies the sender's signature
it must lookup the storage contract by the supplied <code>data_hash</code> and verify that
the sender is the party with which the contract was negotiated. If all tests
pass, then the farmer must respond with a generated token to allow the renter
to open a data channel (via websocket) to retrieve the data as a binary stream.
After the data shard is delivered successfully, the farmer must increment
it's record of the <code>downloads_since_last_audit</code> (which must be reset after the
next audit).</p>
<blockquote>
<p>For more information on the Data Channel specification see the tutorial for
<a href="tutorial-data-channels.html">Transferring File Shards</a>.</p>
</blockquote>
<pre class="prettyprint source"><code>{
  &quot;result&quot;: {
    &quot;token&quot;: &quot;3f62b781e3b5b5288dca587807248261d109bbfb&quot;,
    &quot;contact&quot;: {
      &quot;address&quot;: &quot;10.0.0.2&quot;,
      &quot;port&quot;: 1337,
      &quot;nodeID&quot;: &quot;48dc026fa01ae26822bfb23f98e725444d6775b0&quot;,
      &quot;protocol&quot;: &quot;0.3.0&quot;
    },
    &quot;nonce&quot;: 1455216323786,
    &quot;signature&quot;: &quot;304502207e8a439f2cb33055e0b2e2d90e775f29d90b3ad85aec0c...&quot;
  },
  &quot;id&quot;: &quot;7b6a2ab35da6826995abf3310a4875097df88cdb&quot;
}</code></pre><p>In addition, the renter must check the integrity of the returned <code>data_shard</code>
by calculating the hash and checking it against the expected <code>data_hash</code>. If
the test fails, then this effectively a failed audit and the contract is null.</p>
</article>

</section>

		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>

<div class="modal fade" id="searchResults">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
        <h4 class="modal-title">Search results</h4>
      </div>
      <div class="modal-body"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div>

<footer>


	<span class="copyright">
	Copyright 2016 Storj Labs
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a>
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>
<script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>

<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : false,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			var id = $( heading ).attr( "id" );
			return id && id.replace(/\~/g, '-inner-').replace(/\./g, '-static-') || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->


<script type="text/javascript">
	$(document).ready(function() {
		SearcherDisplay.init();
	});
</script>

</body>
</html>